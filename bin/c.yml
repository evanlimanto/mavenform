q1_1: |
  # Problem 1: (15 points) (10 minutes)
  You, Detective Jack Clouseau, are guarding the coveted Pink Panther diamond, which resides in a safe with a special combination lock. The lock has four dials â€“ each dial consists of numbers 0-9 and letters a, b. 
  <hr class="s2" />
  a) **(5 points)** How many unique combinations are there in your special combination lock?

q1_1_s: |
  Total number of alphabets on each dial = 12 (0-9, a, b)
  <hr class="s1" />
  No. of dials = 4
  <hr class="s1" />
  Ans: $12^4$ unique combinations.

q1_2: |
  b) **(5 points)** Meanwhile, the Phantom is trying to steal the diamond. If it takes him a second to check each combination, and you check on the safe every 15 minutes, what are your chances of catching him? Justify your answer.

q1_2_s: |
  Assuming the initial combination on the lock was completely randomized, it is reasonable to use the time it takes the Phantom to find the right combination in the worst case, which is $12^4$ seconds ~ $345$ min. If you check on the lock every $15$ min, looks like you can catch him with high likelihood!

q1_3: |
  c) **(5 points)** You decide that you want to make a new lock with hundred times the number of possible combinations as the old one. If each dial consists of the same numbers and letters as before, what is the minimum number of dials you need on the new lock?

q1_3_s: |
  We need to find the lowest power of $12$ that would just fit $100 \times 12^4$.
  <hr class="s1" />
  So, we need $2$ more dials.

q2_1: |
  # Problem 2: (40 points) (30 minutes) C Medley
  **(a) (20 points) Fun with Pointers**
  <hr class="s1" />
  For the C code below make the following assumptions
  - i. The base address of `array` is 0x10000000
  - ii. The byte ordering is Little Endian
  - iii. int is 4 bytes

  ```
  int array[3]={-1,1,2};
  int main(){
    unsigned char *ptr1 = (((unsigned char *) array) + 1);
    unsigned char val;
    int *ptr2 = array + 2;
    val = *ptr1;
    return 0;
  }
  ```

  **i) (10 points)** Show the byte level representation of `array` in memory. You have to mark the increasing direction of memory addresses.

q2_1_s: |
  [[q1-1.png]]

q2_2: |
  **ii) (5 points)** What is the value in `*ptr2` before the return statement?

q2_2_s: |
  2

q2_3: |
  **iii) (5 points)** What is the value of the variable `val` before the return statement?

q2_3_s: |
  `0xFF`

q2_4: |
  **(b) (20 points) Buggy Buggy Debuggy**
  <hr class="s2" />
  Consider the following C code

  ```
  int main()
  {
      short disappear[]={1,2,3};
      short index=2;

       do
       {
            disappear[index]=0;

       }while(index-- >=0);
  }
  ```

  **i) (10 points)** Show the entire contents of the array `disappear` at the end of each iteration of the do-while loop, for three iterations.

q2_4_s: |
  [[q2-1.png]]

q2_5: |
  **ii) (5 points)** There is a bug in the above code. Identify it and explain its possible effects on the compilation and execution of the program

q2_5_s: |
  Out of bounds array access because of the condition `while (index-- >= 0);`.
  <hr class="s1" />
  This causes run-time errors: either a segfault or data corruption, which may lead to unpredictable program behavior.

q2_6: |
  **iii) (5 points)** Change the code to correct for the above bug. What are the final values of index and the contents of the array `disappear`, right before main returns?

q2_6_s: |
  Change last line to `while (index-- > 0)`.
  <hr class="s1" />
  After this change `index = -1` and `disappear = [0, 0, 0]` before main returns.

q3_1: |
  # Problem 3: (25 points) (20 minutes) Fill in the code
  **(a) (15 points) Data Structures**
  <hr class="s2" />
  Consider the following definition of a node in a doubly linked list.

  ```
  typedef struct Node ListNode;

  struct Node {
      int data;       // this is the data in this node element
      ListNode* next; // this is a pointer to the next element in the list
      ListNode* prev; // this is a pointer to the previous element in the list
  };
  ```

  The following C function should completely reverse the order of the elements in the list.
  A part of the function is implemented using recursion. Fill in the missing implementation.
  The function is initially called with a pointer to the first `ListNode` object of the list. It
  should ultimately return a pointer to the new first element of the list (which was
  previously the last element)

  ```
  ListNode * reverse(ListNode *aNode)
  {
      /* Your code goes here */
      _________________________________________________
      _________________________________________________
      _________________________________________________
      _________________________________________________
      _________________________________________________
      _________________________________________________
      _________________________________________________
      _________________________________________________

      if (aNode->prev == NULL)    // stop if end of list has been reached
          { return aNode; }
      else
          { return reverse(aNode->prev); } // otherwise continue recursively
  }
  ```

q3_1_s: |
  ```
  ListNode * reverse(ListNode *aNode)
  {
      /* Your code goes here */
      if (aNode == NULL)
          return NULL;
      ListNode *tmp = aNode->prev;
      aNode->prev = aNode->next;
      aNode->next = tmp;

      if (aNode->prev == NULL)    // stop if end of list has been reached
          { return aNode; }
      else
          { return reverse(aNode->prev); } // otherwise continue recursively
  }
  ```

q3_2: |
  **(b) (10 points) C Strings:** The following function should copy `n` characters from string
  `source` to string `dest` starting with the first element of `source`. Fill in the blanks to
  complete the code. There should only be one expression in each while loop, meaning you
  must only fill in the right hand side of the assignment statement in the first while loop,
  and the left hand side of the assignment statement in the second while loop. You should
  not add any additional statements to the code.

  ```
  /* strncpy: copy n characters from source to dest */
  void strncpy (char * dest, char * source, int n)
  {
      while (*source && n-- > 0)
      {
          *dest++ = _____________________________;
      }

      while (n-- > 0)
      {
          ____________________ = 0;
      }
  }
  ```

q3_2_s: |
  ```
  /* strncpy: copy n characters from source to dest */
  void strncpy (char * dest, char * source, int n)
  {
      while (*source && n-- > 0)
      {
          *dest++ = *source++;
      }

      while (n-- > 0)
      {
          *dest++ = 0;
      }
  }
  ```

q4_1: |
  # Problem 4: (25 points) Bit Manipulation (30 minutes)
  Write ARM code for the
  function `isolateRangeOfBits`. This function isolates the bits between lower and
  upper and returns only those bits. You must follow the ARM Procedure Call Standard.
  You must comment your code extensively. Code that is not adequately commented will
  be penalized.

  ```
  isolateRangeOfBits(0x12345678, 0, 8) returns 0x78
  isolateRangeOfBits(0x12345678, 8, 12) returns 0x6
  isolateRangeOfBits(0x12345678, 30, 32) returns 0x0

  /* Precondition: lower <= upper */
    int isolateRangeOfBits(int number, unsigned int lower,
    unsigned int upper);

  isolateRangeOfBits:
  ```

q4_1_s: |
  [[q4-1.png]]

q5_1: |
  # Problem 5: (25 points) Compilation (30 minutes)
  The following function performs a finite impulse response (FIR) filter using input from
  array `z` and coefficients found in integer array `h`.

  ```
  int compute_FIR( int* h, int* z, int ntaps, int input)
  {
      int ii;
      int accum;

      /* store input at the beginning of the delay line */
      z[0] = input;
      /* calc FIR and shift data */
      accum = h[ntaps - 1] * z[ntaps - 1];
      for (ii = ntaps - 2; ii >= 0; ii--) {
          accum += h[ii] * z[ii];
          z[ii + 1] = z[ii];
      }
      return accum;
  }
  ```

  Write the above function in assembly using ARM instructions. Specify the mapping
  between variables and registers in your code. You must follow the ARM Procedure Call
  Standard. 
  <hr class="s2" />
  Mapping:
  <hr class="s2" />
  <hr class="s2" />
  compute_FIR:

q5_1_s: |
  Mapping:

  ```
  Mapping:  h: r0       ii: r4
            z: r1       h[ii]: r5
            ntaps: r2   z[ii]: r6
            input: r3   accum: r7
                        result: 40
  ```

  <hr class="s2" />
  ```
  compute_FIR: push {r4-r11, lr}
               str r3, [r1]; z[0] = input
               sub r4, r2, #1; ntaps -> r4
               ldr r5, [r0, r4, lsl #2]; r5 = h[ntaps - 1]
               ldr r6, [r1, r4, lsl #2]; r6 = z[ntaps - 1]
               mul r7, r5, r6; accum = h[ntaps - 1] * z[ntaps - 1]
               sub r4, r4, #1; r4 = ntaps - 2

  for_loop:    cmp r4, #0;
               blt return
               ldr r5, [r0, r4, lsl #2]; r5 = h[ii]
               ldr r6, [r1, r4, lsl #2]; r6 = z[ii]
               mla r7, r5, r6, r7; accum += h[ii] * z[ii]
               add r4, r4, #1; ii = ii + 1
               str r6, [r1, r4, lsl #2]; z[ii+1] = z[ii]
               sub r4, r4, #2; ii = ii - 2
               b for_loop

  return:      mov r0, r7
               pop {r4-r11, lr}
               bx lr
  ```

q6_1: |
  # Problem 6: (40 points) NO DISASSEMBLE! REASSEMBLE!
  **What kind of pants does Mario wear? DENIM, denim, denim**
  <hr class="s2" />
  Consider the following code:

  ```
  main: MOV r0, #16
        SUB r0, r0,#1
        MOV r1, #5
        ADD r1, r1, r1, LSL #2
        BL mario
        BX lr
  mario: CMP r0,r1
         BEQ yoshi
         BLT luigi
         SUB r0,r0,r1
         B mario
  luigi: SUB r1,r1,r0
         B mario
  yoshi: BX lr
  ```

  **a) (5 points)** How many functions does the above code contain? What is the return value of the `mario` function?

q6_1_s: |
  Two: main & mario
  <hr class="s1" />
  Return value = 5 (in r0)

q6_2: |
  **b) (10 points)** Assume the processor that runs the above code implements a fivestage
  pipeline. Are there any data hazards in the above code, if no special
  mechanisms were in place to deal with data hazards? If yes, identify them and
  justify your answer.

q6_2_s: |
  Yes, there are two data hazards.
  <hr class="s2" />
  1st instance:

  ```
  move r0, #16; r0 updated in the 5th cycle
  sub r0, r0, #1; but is being consumed in the third cycle
  ```

  2nd instance:

  ```
  mov r1, #5; similar situation with r1
  add r1, r1, r1, lsl #2
  ```

q6_3: |
  **c) (5 points)** List two mechanisms to alleviate data hazards. If the processor
  implemented each of these mechanisms, how many cycles does the execution of
  the `main` function take until (but excluding) the call to `mario`? 

q6_3_s: |
  To alleviate the data hazard we could:
  - Stall execution of 1st 4 lines of main will take 5 + 3 + 1 + 3 = 12 cycles
  - Forward result of arithmetic operations to next instruction right after the execute stage. Execution time = 5 + 1 + 1 + 1 = 8 cycles
  - Reordering
  ```
  mov r0, #16
  mov r1, #5
  sub r0, r0, #1
  add r1, r1, r1, lsl #2
  ```
  Execution time 5+1+2+1 = 9 cycles

q6_4: |
  **d) (5 points)** How many bytes of code does the `mario` function use? Assume the
  normal ARM instruction set as we discussed in class (i.e., no Thumb instructions).

q6_4_s: |
  8 (no. of instructions) x 4 (size in bytes of each instruction) = 32 bytes

q6_5: |
  **e) (10 points)** Rewrite the function using the skeleton code below. You only need to
  add three instructions. How many bytes of code does your new implementation of
  `mario` use? 

  ```
  mario    CMP r0, r1
           ______________________________
           ______________________________
           ______________________________
  yoshi    BX lr
  ```

q6_5_s: |
  ```
  mario    CMP r0, r1
           subgt r0, r0, r1
           sublt r1, r1, r0
           bne mario
  yoshi    BX lr
  ```

q6_6: |
  **f) (5 points)** Translate the `mario` function into C. Your function header should list
  the types of any arguments and return values. Also, your code should be as
  concise as possible, without any gotos. 

q6_6_s: |
  ```
  int mario (int x, int y)
  {
      while (x != y)
      {
          if (x < y)
              y = y - x;
          else
              x = x - y;
      }
  }
  ```
