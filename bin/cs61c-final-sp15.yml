course: 'cs61c'

type: 'final'
term: 'sp15'
prof: 'Asanovic, Stojanovic'

q1_1: |
  # M1-1: I smell a potpourri section covering midterm one... (9 points)
  a) Which of the following number representations give `0xFFFFFFFE` the **most positive** value when converted to decimal?
  - A) Bias (with standard bias)
  - B) Unsigned
  - C) Two’s complement
  - D) Sign and Magnitude

q1_1_s: |
  - B) Unsigned

q1_2: |
  b) Consider a plot that shows the mapping between 8-bit two’s complement binary numbers and their decimal equivalents (i.e. binary is on the x-axis and decimal is on the y-axis). Fill in the plot to the left and answer the following questions.
  <hr class="s2" />
  i) Fill in the plot to the left.
  <hr class="s1" />
  ![plot](/img/cs61c/final-sp15-q1-1.png)

q1_2_s: |
  ![plot](/img/cs61c/final-sp15-q1-2.png)

q1_3: |
  ii) Describe (in binary) where discontinuities occur in the plot, if any:

q1_3_s: |
  Discontinuity from `0b01111111` to `0b10000000`. Jumps from positive number to most negative number.

q1_4: |
  iii) What are the most positive and most negative decimal values that this representation can store?

q1_4_s: |
  Largest: 127
  <hr class="s1" />
  Smallest: -128

q1_5: |
  c) Consider the C code below. Indicate where the values on the right live in memory (using **(S)**tack, **(H)**eap, s**(T)**atic, or **(C)**ode). Assume no registers are used:

  ```
  #define a 10
  int b = 0;

  int main(int argc, char** argv) {
      int c = a;
      char d[10];
      int* e = malloc(sizeof(int));
  }
  ```

  **a: ________**
  <hr class="s1" />
  **b: ________**
  <hr class="s1" />
  **\*d: ________**
  <hr class="s1" />
  **\*e: ________**
  <hr class="s1" />
  **e: ________**

q1_5_s: |
  **a: C**
  <hr class="s1" />
  **b: T**
  <hr class="s1" />
  **\*d: S**
  <hr class="s1" />
  **\*e: H**
  <hr class="s1" />
  **e: S**

q1_6: |
  d) Convert the following instructions from TAL to hex or vice versa. Use register names when possible.

  ```
  i) lw $s0, 0($a0)
  ```

  <hr class="s2" />

  ```
  ii) 0x02021021
  ```

q1_6_s: |
  ```
  i) lw $s0, 0($a0)
  0x8c900000

  ii) 0x02021021
  addu $v0 $s0 $v0
  ```

q2_1: |
  # M1-2: I'll believe it when I C it (9 points)
  Your friend wants to take 61C next semester, and is learning C early to get ahead. They try to implement the ROT13 function as practice, but the code they wrote has some bugs, so you’ve been called in, as the C expert, to help debug their program, reproduced below:

  ```
  /* Applies the ROT13 cipher. rot13("happytimes") == " uncclgvzrf" */
  void rot13(char *str) {
      while (*str) {
          if (str >= 'a' && str <= 'z') {
              *str = (*str + 13) % 26;
          }
          str++;
      }
  }

  int main(int argc, char *argv[]) {
      char a[] = "happy";
      char b[] = "times";
      char *s = "XXXXXXXXXXXX"; // 12 X's

      // Apply cipher to a and b.
      rot13(a);
      rot13(b);
      printf("%s%s\n", a, b);

      // Concatenate and place in s.
      int i = 0;
      for (int j = 0; a[j]; ) s[i++] = a[j++];
      for (int j = 0; b[j]; ) s[i++] = b[j++];

      printf("%s\n", s);
  }
  ```

  a) You want to impress your friend, so you predict the result of executing the program as it is written, just by looking at it. If the program is guaranteed to execute without crashing, describe what it prints, otherwise explain the bug that may cause a crash.

q2_1_s: |
  Modifying string literals is undefined, causes a bus error in modern systems.

q2_2: |
  b) Now, fix all the errors in the program so that it executes correctly. Fill in the corrections you made in the table below. You may not need all the rows.

  |Line #|Insert Before / Replace / Delete|Change (Explanation or Code)|
  |------|--------------------------------|----------------------------|
  ||||
  ||||
  ||||
  |||||

q2_2_s: |
  |Line #|Insert Before / Replace / Delete|Change (Explanation or Code)|
  |------|--------------------------------|----------------------------|
  |4|Replace|`if (*str >= 'a' && *str <= 'z') {`|
  |5|Replace|`*str = (*str - 'a' + 13) % 26 + 'a';`|
  |14|Replace|Change `char *s` to `char s[]`|
  |25|I / R|`s[i] = '\0';`|

q3_1: |
  # M1-3: I don't want to MIPS a thing (9 points)
  The following C code recursively sums the elements in an array of length `n`.

  ```
  int32_t sum_arr(int32_t *arr, size_t n) {
      if (n) {
          return sum_arr(arr + 1, n - 1) + arr[0];
      }
      return 0;
  }
  ```

  Translate `sum_arr` into MIPS below. Your code must follow all function calling conventions, and you may not use any pseudoinstructions. You may not need every blank.

  ```
  sum_arr:  ____________ non_zero
            addu $v0, $0, $0
            jr $ra
  non_zero: _____________________
            _____________________
            _____________________
            _____________________
            addiu $s0, $a0, 0        # Store arr into $s0
            _____________________
            _____________________
            _____________________
            _____________ sum_arr    # Make the recursive call
            _____________________    # Then add arr[0] to the result
            _____________________
            _____________________
            _____________________
            _____________________
            _____________________
            jr $ra
  ```

q3_1_s: |
  ```
  sum_arr:  _bne $a1, $zero_ non_zero
            addu $v0, $0, $0
            jr $ra
  non_zero: _addiu $sp, $sp, -8__
            _sw $s0, 4($sp)______
            _sw $ra, 0($sp)______
            _____________________
            addiu $s0, $a0, 0        # Store arr into $s0
            _addiu $a0, $a0, 4___
            _addiu $a1, $a1, -1__
            _____________________
            _jal________ sum_arr     # Make the recursive call
            _lw $t0, 0($s0)______    # Then add arr[0] to the result
            _addu $v0, $v0, $t0__
            _lw $s0, 4($sp)______
            _lw $ra, 0($sp)______
            _addiu $sp, $sp, 8___
            _____________________
            jr $ra
  ```

q4_1: |
  # M2-1: I couldn't come up with a clever title for SDS. (10 points)
  a) Give the simplest Boolean expression for the following circuit in terms of `A` and `B`, using the minimum number of AND, OR, and NOT gates:
  <hr class="s2" />
  ![circuit](/img/cs61c/final-sp15-q4-1.png)
  <hr class="s2" />
  ```
  C = ________________________________
  ```
  (You must show your work above to earn points.)

q4_1_s: |
  ```
  C = A + ~B
  ```

q4_2: |
  b) Using as few states as possible, complete the transition table for an FSM that takes an input with 3 values: 0, 1, or 2. The machine will output a 1 when the sum of the inputs seen so far is divisible by 3. Otherwise it should output a 0.
  <hr class="s2" />
  Assume you have seen no digits at the start state. You might not need all of the states, and you should not draw additional states. You must represent your FSM using the table to the left, **the table is the only part that will be graded.** The first transition has been filled in for you.
  <hr class="s2" />
  ![states](/img/cs61c/final-sp15-q4-2.png)

q4_2_s: |
  ![states](/img/cs61c/final-sp15-q4-3.png)

q4_3: |
  c) Suppose we add registers to the unoptimized circuit in part A to increase the clock rate (this modification is shown below). What is the longest clock-to-Q that the registers on inputs A and B can have that will result in correct behavior when the circuit is clocked at 10 MHz?
  <hr class="s2" />
  ![circuit](/img/cs61c/final-sp15-q4-4.png)
  <hr class="s2" />
  - Assume that clock-to-Q > hold time
  - All registers have a setup time of 2 ns
  - All logic gates have a delay of 25 ns
  - Bubbles on gates do not introduce additional delay

  <hr class="s2" />
  Answer: ________________

q4_3_s: |
  Answer: 48 ns

q5_1: |
  # M2-2: Float like a butterfly and sting like an IEEE (4 points)
  Let's take another look at the IEEE754 standard for single-precision floating-point numbers. [x, y) represents a range where x is included and y is not.
  <hr class="s1" />
  a) How many floats are representable in the interval [0.5, 1)?
  <hr class="s1" />
  Answer: ____⋅2^____

q5_1_s: |
  Answer: 1⋅2^23

q5_2: |
  b) How many floats are representable in the interval [0, 0.5)?
  <hr class="s1" />
  Answer: ____⋅2^____

q5_2_s: |
  Answer: 126 ⋅ 2^ 23 + 1

q6_1: |
  # M2-3: If this exam were a CPU, you'd be halfway through the pipeline (8 points)
  We found that the instruction fetch and memory stages are the critical path of our 5-stage pipelined MIPS CPU. Therefore, we changed the IF and MEM stages to take **two** cycles while increasing the clock rate. You can assume that the register file is written at the falling edge of the clock.
  <hr class="s2" />
  ![pipeline](/img/cs61c/final-sp15-q6-1.png)
  <hr class="s2" />
  Assume that no pipelining optimizations have been made, and that branch comparisons are made by the ALU. Here’s how our pipeline looks when executing two add instructions:
  <hr class="s2" />

  |Clock Cycle #|1|2|3|4|5|6|7|8|
  |-------------|-|-|-|-|-|-|-|-|
  |add $t0, $t1, $t2|IF1|IF2|ID|EX|MEM1|MEM2|WB||
  |add $t3, $t4, $t5||IF1|IF2|ID|EX|MEM1|MEM2|WB|

  <hr class="s2" />
  Make sure you take a careful look at the above diagram before answering the following questions:
  <hr class="s2" />
  a. How many stalls would a data hazard between back-to-back instructions require?

q6_1_s: |
  3 stalls

q6_2: |
  b. How many stalls would be needed after a branch instruction?

q6_2_s: |
  4 stalls

q6_3: |
  c. Suppose the old clock period was 150 ns and the new clock period is now 100 ns. Would our processor have a significant speedup executing a large chunk of code...
  <hr class="s1" />
  i. Without any pipelining hazards? Explain your answer in 1-2 sentences.

q6_3_s: |
  Yes, due to 1.5x throughput

q6_4: |
  ii. With 50% of the code containing back-to-back data hazards? Explain your answer in 1-2 sentences.

q6_4_s: |
  Yes, penalty is 300 ns per hazard in both cases, so our new processor will still have higher throughtput.

q7_1: |
  # M2-4: Some say there's nothing better than cold, hard cache (12 points)
  a) What shape do the following trade-off curves have? Select a shape and enter its number into the box for each of the graphs. Unless they are the parameters being varied, assume that associativity, capacity and block size are constant. You should assume that the axes are linear.
  <hr class="s2" />
  ![curves](/img/cs61c/final-sp15-q7-1.png)

q7_1_s: |
  ![curves](/img/cs61c/final-sp15-q7-2.png)

q7_2: |
  b) Consider a system with inclusive L1 and L2 caches with 4B cache block size. Assume we have 1 MiB of on-chip memory available and want to determine how much of this memory we should give to the L1 cache and how much to the L2 cache. We will try to minimize the AMAT to do so.
  <hr class="s2" />
  Assume both caches are fully associative with LRU replacement. Their combined capacity is 1MiB (excluding tags and meta-data). **You can consider all miss rates approximate.**
  <hr class="s2" />
  Say you are running the following program starting from cold L1 and L2 caches:

  ```
  #define ARRAY_SIZE 256*1024
  int a[ARRAY_SIZE];
  int sum = 0; // assume sum, i, and j are stored in registers
  for (int i = 0; i < 100000; i++) {
      for (int j = 0; j < ARRAY_SIZE; j++) sum += a[j];
      for (int j = ARRAY_SIZE-1; j >= 0; j--) sum += a[j];
  }
  ```

  1) How would we compute AMAT if we had the local L1 miss rate (“L1Miss”), the local L2 miss rate (“L2Miss”) and the memory access time (“Memory”)? Use “H1” and “H2” to represent the L1 and L2 hit times respectively. (We will compute these quantities later in the question)

q7_2_s: |
  AMAT = H1 + L1Miss * (H2 + L2Miss * Memory)

q7_3: |
  # M2-4: (continued)
  2) For the program above, express the local miss rate for the L1 cache in general terms as a function of the L1 cache size (write L1 for the size of L1 in bytes). Hint: The miss rate is 0 for a 1 MiB cache, 0.5 for a 0.5 MiB cache and 1 for a 0 MiB (i.e., no) L1 cache.

q7_3_s: |
  LocalMiss1 = 1 – (L1/1MiB)

q7_4: |
  3) What is the global miss rate for the L2 cache as a function of the L1 cache size? Hint: Start by expressing the global miss rate as a function of the L2 cache size.

q7_4_s: |
  GlobalMiss2 = 1-(L2/1MiB) = (1MiB-L2)/1MiB = L1/1MiB

q7_5: |
  4) What is the local miss rate for the L2 cache as function of the L1 and L2 sizes? Hint: Use your results from questions 2 and 3.

q7_5_s: |
  LocalMiss2 = [L1/1MiB] / [1 – (L1/1MiB)] = L1/(1MiB-L1) = L1/L2

q7_6: |
  5) Assume the hit time of the L1 cache is 10 cycles, the hit time of the L2 cache is 20 cycles and the memory access time is 100 cycles. Using the formula from question 1, what is the AMAT for this system as a function of only the L1 size?

q7_6_s: |
  AMAT = H1 + LocalMiss1 * (H2 + LocalMiss2 * Memory)
  <hr class="s1" />
  = 10 + [L2/1MiB]*[20 + (L1/L2)*100]
  <hr class="s1" />
  = 10 + (1MiB-L1)*20/1MiB + L1*100/1MiB
  <hr class="s1" />
  = 10 + 20 – 20*L1/1MiB + 100*L1/1MiB
  <hr class="s1" />
  = 30 + 80*L1/1MiB

q7_7: |
  6) What sizes of L1 and L2 caches should we pick to minimize the AMAT? (assume the caches have non-zero size, i.e., both of them exist)

q7_7_s: |
  L1 = 4B, L2 = 1MiB-4B

q8_1: |
  # F1: Paging all CS61C students (9 points)
  Consider a byte-addressed machine with a 13-bit physical address space that can hold two pages in memory. Every process is given 16MiB of virtual memory and pages are evicted with an LRU replacement scheme.
  <hr class="s2" />
  a) What are the sizes of the following fields in bits?
  - Virtual Page Number: ________
  - Virtual Address Offset: ________
  - Physical Page Number: ________
  - Physical Address Offset: ________

q8_1_s: |
  - Virtual Page Number: 12
  - Virtual Address Offset: 12
  - Physical Page Number: 1
  - Physical Address Offset: 12

q8_2: |
  b) Consider the following code snippet:

  ```
  // a and b are both valid pointers to
  // different arrays of length ARRAY_SIZE
  void enumerate(int* a, int* b) {
       for (int i = 0; i < ARRAY_SIZE; i++) {
            a[i] = i;
            b[i] = ARRAY_SIZE - i;
       }
  }
  ```

  The compiled binary for the program containing this code snippet weighs in at 4096B. If this code was executed on the machine, what is the maximum value of `ARRAY_SIZE` that would allow this code to execute with 0 page faults in the best-case scenario? (Answer in IEC prefix: 8Gi, 32Ti, etc)

q8_2_s: |
  Page Size: 4KiB
  <hr class="s1" />
  Each array must be 2KiB = 2^11 / 4 = 512 ints longA
  <hr class="s2" />
  `ARRAY_SIZE =` ________

q8_3: |
  c) How could we modify the above code snippet to allow a larger `ARRAY_SIZE` and execute with the fewest page faults in the best-case scenario? Write the new code below:

q8_3_s: |
  ```
  for (int i = 0; i < ARRAY_SIZE; i++)
      a[i] = i;
  for (int i = 0; i < ARRAY_SIZE; i++)
      b[i] = ARRAY_SIZE - i;
  ```

  Access each array sequentially by splitting the for loop into two separate loops. Now each array can be as large as a page.

q9_1: |
  # F2: Why can’t you use parallelism at a gas station? It might cause a spark. (10 points)
  1. Optimize `factorial()` using SIMD intrinsic(AVX).

  ```
  double factorial(int k) {
      int i;
      double f = 1.0;
      for (i = 1 ; i <= k ; i++) {
          f *= (double) i;
      }
      return f;
  }
  ```

  You might find the following intrinsics useful:
  <hr class="s1" />
  $\begin{align}
  \text{__m256d _mm256_loadu_pd}(\text{double} \*s) & \; \text{returns vector} \; (s[0], s[1], s[2], s[3]) \\\\
  \text{void _mm256_store_pd}(\text{double} \*s, \text{__m256d v}) & \; \text{stores} \; p[i] = v_i \; \text{where} \; i = 0, 1, 2, 3 \\\\
  \text{__m256d _mm256_mul_pd}(\text{__m256d a, __m256d b}) & \; \text{returns vector} \; (a_0b_0, a_1b_1, a_2b_2, a_3b_3)
  \end{align}$

  <hr class="s2" />
  ```
  double factorial(int k) {
      int i, j;
      double f_init[] = {1.0, 1.0, 1.0, 1.0};
      double f_res[4];
      double f = 1.0;
      // initialize f_vec
      __m256d f_vec = ________________
      // vectorize factorial
      for (i = 1 ; i <= ________________ ; ________________) {
          double l[] = {
              (double) ________________, (double) ________________,

              (double) ________________, (double) ________________};

          __m256d data = ________________

          ________________________________
      }
      // reduce vector
      _____________________________
      for (j = 0 ; j < 4 ; j++) {
          f = ________________________________;
      }
      // handle tails
      for ( ; i <= k ; i++) {
          ________________________________
      }
      return f;
  }
  ```

q9_1_s: |
  ```
  double factorial(int k) {
      int i, j;
      double f_init[] = {1.0, 1.0, 1.0, 1.0};
      double f_res[4];
      double f = 1.0;
      // initialize f_vec
      __m256d f_vec = __mm256_loadu_pd(f_init);

      // vectorize factorial
      for (i = 1 ; i <= _k / 4 * 4 ; __i += 4) {
          double l[] = {
            (double) __i, (double) _i+1,
            (double) _i+2, (double) _i+3};
          __m256d data = __mm256_loadu_pd(l);
          _f_vec = _mm256_mul_pd(f_vec, data)_;
      }
      // reduce vector
      __mm256_store_pd(f_res, f_vec);
      for (j = 0 ; j < 4 ; j++) {
          f = _f * f_res[j];
      }
      // handle tails
      for ( ; i <= k ; i++) {
          _f *= (double) i;
      }
      return f;
  }
  ```

q9_2: |
  # F2: (continued)
  2. **Cache Coherence:**
  <hr class="s1" />
  We are given the task of counting the number of even and odd numbers in an array, A, which only holds integers greater than 0. Using a single thread is too slow, so we have decided to parallelize it with the following code:

  ```
  #include < stdio.h >
  #include "omp.h"
  void count_eo (int *A, int size, int threads) {
      int result[2] = {0, 0};
      int i, j;

      omp_set_num_threads(threads);

      #pragma omp parallel for
      for (j=0; j < size; j++)
          result[(A[j] % 2 == 0) ? 0 : 1] += 1;

      printf("Even: %d\n", result[0]);
      printf("Odd: %d\n", result[1]);
  }
  ```

  As we increase the number of threads running this code:
  <hr class="s1" />
  a) Will it print the correct values for Even and Odd? If not, explain the error.

q9_2_s: |
  No, there may be a data race.

q9_3: |
  b) Can there be false sharing if the cache block size is 8 bytes?

q9_3_s: |
  yes

q9_4: |
  c) What about 4 bytes?

q9_4_s: |
  No

q10_1: |
  # F3: This isn't a bathroom. Why is there potpourri? (10 points)
  1. **T/F Questions (Circle one. If the circling is unclear, you will receive no credit.)**
  - 1) CPUs need separate instructions to access I/O devices. (True / False)
  - 2) Segmentation (base + bound) has fragmentation problems. (True / False)
  - 3) Exceptions in early pipeline stages override exceptions in later stages for a given instruction. (True / False)
  - 4) Exceptions are handled in the pipeline stage where they occur. (True / False)

q10_1_s: |
  - 1) CPUs need separate instructions to access I/O devices. False
  - 2) Segmentation (base + bound) has fragmentation problems. True
  - 3) Exceptions in early pipeline stages override exceptions in later stages for a given instruction. True
  - 4) Exceptions are handled in the pipeline stage where they occur. False

q10_2: |
  2. **Polling, Interrupts, and DMA**
  <hr class="s2" />
  1) Choosing polling or interrupt for the following devices.
  <hr class="s2" />

  |Device|Data Rate|Transfer Block Size|Polling/Interrupt?|
  |------|---------|-------------------|------------------|
  |A|80B/s|4B||
  |B|400MB/s|4B||
  |C|400MB/s|2KB|||

q10_2_s: |
  |Device|Data Rate|Transfer Block Size|Polling/Interrupt?|
  |------|---------|-------------------|------------------|
  |A|80B/s|4B|Polling|
  |B|400MB/s|4B|Interrupt|
  |C|400MB/s|2KB|Interrupt|

q10_3: |
  2) To support interrupts, the CPU should be able to save and restore the current state. Which of the following should be saved before handling interrupts to ensure correct execution?
  <hr class="s2" />
  $\text{a. Program Counter} \quad \text{b. User Registers} \quad \text{c. TLB} \quad \text{d. Caches}$

q10_3_s: |
  a, b

q10_4: |
  3) To which device in 1) is direct memory access (DMA) most beneficial? Explain briefly.

q10_4_s: |
  Device C. CPU can do useful work while transferring large data blocks.

q10_5: |
  3. **Warehouse Scale Computing and Amdahl's Law.**
  <hr class="s2" />
  1) We are going to train convolutional neural networks on Amazon EC2. It turns out that 90% of training can be parallelized but the rest takes twice as long due to the communication overhead among the instances. What is the maximum speedup we can achieve?

q10_5_s: |
  $1 / (0.9 / s + 2 * 0.1) \le 5 \implies \; \text{Maximum speedup} \; = 5$

q10_6: |
  2) Which of the following can increase the maximum speedup in 1)?
  - a. Use more instances
  - b. Deploy the application across multiple arrays.
  - c. Reduce the number of reduce operations.
  - d. Increase network bandwidth.
  - e. Increase the capacity of disks.

q10_6_s: |
  c, d

q10_7: |
  4. **Hamming Error-Correction Code (ECC)**
  <hr class="s1" />
  1) Suppose we have a one-byte data value, $0110_{two}$. Fill in the encoded data in the following table.
  <hr class="s2" />
  ![table](/img/cs61c/final-sp15-q10-1.png)

q10_7_s: |
  ![table](/img/cs61c/final-sp15-q10-2.png)

q10_8: |
  2) Assume that we have an encoded value, $1001110_{two}$ with a single-bit error. Indicate below each parity bit if it has an error:
  <hr class="s2" />

  |Parity Bit|P1|P2|P4|
  |----------|--|--|--|
  |OK/ERROR|||||

  <hr class="s2" />
  Incorrect bit position: ________________
  <hr class="s1" />
  Correct data: ________________

q10_8_s: |
  |Parity Bit|P1|P2|P4|
  |----------|--|--|--|
  |OK/ERROR|OK|Error|Error|

  <hr class="s2" />
  Incorrect bit position: 6
  <hr class="s1" />
  Correct data: $0100_{two}$

q10_9: |
  5. **Dependability and RAID**
  <hr class="s2" />
  1) Which of the following can increase the availability?
  - a. Increasing MTTF
  - b. Decreasing MTTF
  - c. Increasing MTTR
  - d. Decreasing MTTR
  - e. Redundant data copies

q10_9_s: |
  a, d, e

q10_10: |
  2) Explain very briefly why RAID1 is the most expensive form of RAID.

q10_10_s: |
  Mirrored disk $\to$ 100% overhead

q10_11: |
  3) How many check disks are needed for RAID3?

q10_11_s: |
  1

q10_12: |
  4) Explain why RAID5 has higher write throughput than RAID4.

q10_12_s: |
  Check information is distributed across all disks in a group.
