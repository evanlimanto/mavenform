course: 'cs61c'
ref: 'mt1-sp16'

type: 'mt1'
term: 'sp16'
prof: 'Stojanovic, Weaver'
md: false

questions: {
  'q1': 'Instructors keep their students aligned',
  'q2': 'This tree question need acory pun',
  'q3': 'A filter in the blank question',
  'q4': 'Have you seen this MIPStery before?',
  'q5': 'MIPS Instructions Per Second',
  'q6': 'Mishmash, Hodgepodge, Potpourri'
}

parts: {
  'q1': 2,
  'q2': 1,
  'q3': 1,
  'q4': 3,
  'q5': 3,
  'q6': 4
}

pre: |
  <div class="content-spacer"></div>

q1_1: |
  <h3>Q1: Instructors keep their students aligned (10 points)</h3>

  Consider the C code below. Assume ints and pointers are 4 bytes in size. Remember that C structs
  are densely packed, meaning their elements are contiguous in memory, and that structs <b>may include</b>
  padding at the end for alignment. Each struct is located at a memory address that is a <b>multiple of the size of its largest element</b>.
  <hr class="s2" />
  <code>
  #include &lt;stdio.h&gt;
  <hr class="s1" />
  #include &lt;stdlib.h&gt;
  <hr class="s2" />
  typedef struct {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;char *name;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;unsigned int id;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;char grade;
  <hr class="s1" />
  } Student;
  <hr class="s2" />
  int main(void) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;Student *students = malloc(2 * sizeof(Student));
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;students[0].name = "Oski Bear";
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;students[0].id = 12345;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;students[0].grade = 'A';
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;students[1].name = "Ken Thompson";
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;students[1].id = 5678;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;students[1].grade = 'A';
  <hr class="s2" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("students: %p\n", students);
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("Address of students[0]: %p\n", &(students[0]));
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("Address of students[0].id: %p\n", &(students[0].id));
  <hr class="s2" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("students + 1: %p\n", students + 1);
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("Address of students[1].grade: %p\n",
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&(students[1].grade));
  <hr class="s2" />
  &nbsp;&nbsp;&nbsp;&nbsp;return 0;
  <hr class="s1" />
  }
  </code>

  <hr class="s2" />

  a)  Fill in the blanks in the program’s output below. Assume that the region of memory on the heap allocated by the call to malloc starts at address <code>0x1000</code>. Also, remember that C will print pointer values and memory addresses in <b>hexadecimal notation</b>.
  <hr class="s2" />
  <code>
  students: 0x1000
  <hr class="s1" />
  Address of students[0]: <code>________</code>
  <hr class="s1" />
  Address of students[0].id: <code>________</code>
  <hr class="s1" />
  students + 1: <code>________</code>
  <hr class="s1" />
  Address of students[1].grade: <code>________</code>
  </code>

q1_1_s: |
  <code>
  &nbsp;&nbsp;&nbsp;&nbsp;students: 0x1000
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;Address of students[0]: <b>0x1000</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;Address of students[0].id: <b>0x1004</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;students + 1: <b>0x100C</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;Address of students[1].grade: <b>0x1014</b>
  </code>

q1_2: |
  b)  <b>True | False</b> - The address of the <code>students</code> pointer is less than its value.
  <hr class="s1" />
  i.e. <code>&students < students</code>

q1_2_s: |
  <b>False</b>

q2_1: |
  <h3>Q2: This tree question needs acorny pun (10 points)</h3>
  ucted using t: |
  tree_node <code>struct</code> as defined. Each node can have an arbitrary number of children. Assume that there will always be a valid pointer in the location of children.

  <hr class="s2" />

  <code>
  struct tree_node {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;int value;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;struct tree_node ** children;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;int num_children;
  <hr class="s1" />
  }

  <hr class="s2" />

  int sum_and_free_tree( struct tree_node * root ) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;int i, sum;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;if ( root == NULL ) { // This is equivalent to being stumped
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;sum = _______________________________________________;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;for ( i = ____________;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;____________;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;____________ ) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_______________________________________________;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;free( _______________________________________________ );
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;free( _______________________________________________ );
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;return sum;
  <hr class="s1" />
  }
  </code>

q2_1_s: |
  <code>
  int sum_and_free_tree( struct tree_node * root ) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;int i, sum;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;if ( root == NULL ) { // This is equivalent to being stumped
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;sum = <b>root->value</b>;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;for ( i = <b>0</b>;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>i < root->num_children</b>;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>i++</b> ) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>sum += sum_and_free_tree((root->children)[i])</b>;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;free( <b>root->children</b> );
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;free( <b>root</b> );
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;return sum;
  <hr class="s1" />
  }
  </code>

q3_1: |
  <h3>Q3: A filter in the blank question (20 points)</h3>

  Convert the <code>filter_array</code> function, which counts the number of elements greater than <code>min_val</code> in
  the array and returns an integer, to MIPS assembly. You may not need all of the lines, but you should
  try to use as few lines as possible.
  <hr class="s1" />
  Assume <code>$a0 = arr, $a1 = n, $a2 = min_val</code>.

  <hr class="s2" />

  <code>
  int filter_array(int* arr, size_t n, int min_val) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;int count = 0, i;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i < n; i++){
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] > min_val)
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;return count;
  <hr class="s1" />
  }

  <hr class="s2" />
  <hr class="s2" />
  <b>Example:</b>
  <hr class="s1" />
  int* p = (int*) malloc(sizeof(int)*3)
  <hr class="s1" />
  p[0] = 1;
  <hr class="s1" />
  p[1] = 2;
  <hr class="s1" />
  p[2] = 3;
  <hr class="s1" />
  printf("%d\n", filter_array(p,3,1))
  <hr class="s1" />
  <b>Output: 2</b>
  <hr class="s2" />
  <hr class="s2" />

  filter_array:
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;addiu $sp, $sp, ____
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;___________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;___________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;___________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;addiu $s0, $zero, 0  <b># We’ll store the count in $s0</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;addiu $s1, $zero, 0  <b># We'll store i in $s1</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;addiu $t0, $a0, 0
  <hr class="s1" />
  loop:
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;beq _______________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;lw $t1, ___________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;slt $t2, _____, ___
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;___________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;___________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;___________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;j loop
  <hr class="s1" />
  done:
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;___________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;___________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;___________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;___________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;addiu $sp, $sp, ___
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;jr $ra
  </code>

q3_1_s: |
  <code>
  filter_array:
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;addiu $sp, $sp, <b>-8</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;<b>sw $s0, 0($sp)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;<b>sw $s1, 4($sp)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;___________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;addiu $s0, $zero, 0 &nbsp;&nbsp;&nbsp;&nbsp; <b># We’ll store the count in $s0</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;addiu $s1, $zero, 0 &nbsp;&nbsp;&nbsp;&nbsp; <b># We'll store i in $s1</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;addiu $t0, $a0, 0
  <hr class="s1" />
  loop:
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;beq <b>$s1, $a1, done</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;lw $t1, <b>0($t0)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;slt $t2, <b>$a2</b>, <b>$t1</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;<b>addu $s0, $s0, $t2</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;<b>addiu $s1, $s1, 1</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;<b>addiu $t0, $t0, 4</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;j loop
  <hr class="s1" />
  done:
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;<b>addiu $v0, $s0, 0</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;<b>lw $s0, 0($sp)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;<b>lw $s1, 4($sp)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;___________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;addiu $sp, $sp, <b>8</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;jr $ra
  </code>

q4_1: |
  <h3>Q4: Have you seen this MIPStery before? (25 points)</h3>

  The following is a recursive function that saves its arguments and return address on the stack as it executes.

  <hr class="s2" />

  <code>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mystery:
  <hr class="s1" />
  0x4000&nbsp;&nbsp;&nbsp;&nbsp;bne $a0, $0, recurse
  <hr class="s1" />
  0x4004&nbsp;&nbsp;&nbsp;&nbsp;li $v0, 1
  <hr class="s1" />
  0x4008&nbsp;&nbsp;&nbsp;&nbsp;jr $ra
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recurse:
  <hr class="s1" />
  0x400C&nbsp;&nbsp;&nbsp;&nbsp;addiu $sp, $sp, -8
  <hr class="s1" />
  0x4010&nbsp;&nbsp;&nbsp;&nbsp;sw $ra, 0($sp)
  <hr class="s1" />
  0x4014&nbsp;&nbsp;&nbsp;&nbsp;sw $a0, 4($sp)
  <hr class="s1" />
  0x4018&nbsp;&nbsp;&nbsp;&nbsp;addiu $a0, $a0, -1
  <hr class="s1" />
  0x401C&nbsp;&nbsp;&nbsp;&nbsp;jal mystery
  <hr class="s1" />
  0x4020&nbsp;&nbsp;&nbsp;&nbsp;lw $ra, 0($sp)
  <hr class="s1" />
  0x4024&nbsp;&nbsp;&nbsp;&nbsp;lw $a0, 4($sp)
  <hr class="s1" />
  0x4028&nbsp;&nbsp;&nbsp;&nbsp;addiu $sp, $sp, 8
  <hr class="s1" />
  0x402C&nbsp;&nbsp;&nbsp;&nbsp;mult $a0, $v0
  <hr class="s1" />
  0x4030&nbsp;&nbsp;&nbsp;&nbsp;mflo $v0
  <hr class="s1" />
  0x4034&nbsp;&nbsp;&nbsp;&nbsp;jr $ra
  </code>

  <hr class="s2" />

  a)  If the function is called with the argument <code>$a0</code> set to 5, what values will be in registers <code>$a0</code> and <code>$ra</code> before you return from the base case?

q4_1_s: |
  <b>$a0 = 0</b>
  <hr class="s1" />
  <b>$ra = 0x4020</b>

q4_2: |
  b)  What does the stack look like at the beginning of the base case?
  <hr class="s1" />
  Write your answers in the table below. Assume that, when the function is first called, <code>$a0</code> is set to <code>5</code> and <code>$ra</code> is set to <code>0x1000</code>. Remember that the stack starts at the top and expands downward.
  Each box is <b>one word</b>, and you only need to fill in the box with the hexadecimal value.

  <hr class="s2" />

  <table>
  <thead><tr><th>Stack Block #</th><th>Value</th></tr></thead>
  <tr><td>1</td><td></td></tr>
  <tr><td>2</td><td></td></tr>
  <tr><td>3</td><td></td></tr>
  <tr><td>4</td><td></td></tr>
  <tr><td>5</td><td></td></tr>
  <tr><td>6</td><td></td></tr>
  <tr><td>7</td><td></td></tr>
  <tr><td>8</td><td></td></tr>
  <tr><td>9</td><td></td></tr>
  <tr><td>10</td><td></td></tr>
  <tr><td>11</td><td></td></tr>
  <tr><td>12</td><td></td></tr>
  </table>

q4_2_s: |
  <table>
  <thead><tr><th>Stack Block #</th><th>Value</th></tr></thead>
  <tr><td>1</td><td><b>0x5</b></td></tr>
  <tr><td>2</td><td><b>0x1000</b></td></tr>
  <tr><td>3</td><td><b>0x4</b></td></tr>
  <tr><td>4</td><td><b>0x4020</b></td></tr>
  <tr><td>5</td><td><b>0x3</b></td></tr>
  <tr><td>6</td><td><b>0x4020</b></td></tr>
  <tr><td>7</td><td><b>0x2</b></td></tr>
  <tr><td>8</td><td><b>0x4020</b></td></tr>
  <tr><td>9</td><td><b>0x1</b></td></tr>
  <tr><td>10</td><td><b>0x4020</b></td></tr>
  <tr><td>11</td><td><b></b></td></tr>
  <tr><td>12</td><td><b></b></td></tr>
  </table>

q4_3: |
  c) In a sentence, what does this function do? Assume that <code>$a0</code> is unsigned.

q4_3_s: |
  <b>Computes the factorial of $a0.</b>

q5_1: |
  <h3>Q5: MIPS Instructions Per Second (20 points)</h3>

  Assume <code>$a0</code> contains some positive integer, and <code>$a1</code> contains the address to the start of an integer
  array. The numbers on the left are line numbers; they aren't related to the address of each line, and
  the address of the instruction on line 0 is <code>0x00000000</code>. Consider the following MIPS code and its
  instruction format representation:
  <hr class="s2" />
  <code>
  0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add $t0 $a0 $0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00804020
  <hr class="s1" />
  1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add $t1 $a1 $0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__________
  <hr class="s1" />
  2&nbsp;&nbsp;&nbsp;&nbsp;LabelA:&nbsp;&nbsp;&nbsp;&nbsp;add $t2 $0 $0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00005020
  <hr class="s1" />
  3&nbsp;&nbsp;&nbsp;&nbsp;LabelB:&nbsp;&nbsp;&nbsp;&nbsp;beq $t0 $0 END&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__________
  <hr class="s1" />
  4&nbsp;&nbsp;&nbsp;&nbsp;LabelC:&nbsp;&nbsp;&nbsp;&nbsp;addi $t0 $t0 -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__________
  <hr class="s1" />
  5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lw $t3 0($t1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__________
  <hr class="s1" />
  6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x014b5020
  <hr class="s1" />
  7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addi $t1 $t1 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x21290004
  <hr class="s1" />
  8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x08000003
  <hr class="s1" />
  9&nbsp;&nbsp;&nbsp;&nbsp;END:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add $v0 $t2 $0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01201020
  <hr class="s1" />
  </code>
  <hr class="s2" />
  a)  Convert the following lines to their machine code representation. Write your representation in binary. Each of the boxes is divided into 8 sections of 4 bits each; please format your answer
  accordingly. Line 1 is given as an example.
  <hr class="s2" />
  Line 1:
  <hr class="s1" /><table><tbody><tr><td>0000</td><td>0000</td><td>1010</td><td>0000</td><td>0100</td><td>1000</td><td>0010</td><td>0000</td></tr></tbody></table>
  <hr class="s1" />
  Line 3:
  <hr class="s1" />
  <table><tbody><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td></tr></tbody></table>
  <hr class="s1" />
  Line 4:
  <hr class="s1" />
  <table><tbody><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td></tr></tbody></table>
  Line 5:
  <hr class="s1" />
  <table><tbody><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td></tr></tbody></table>

q5_1_s: |
  Line 1:
  <hr class="s1" />
  <table><tbody><tr><td>0000</td><td>0000</td><td>1010</td><td>0000</td><td>0100</td><td>1000</td><td>0010</td><td>0000</td></tr></tbody></table>
  <hr class="s1" />
  Line 3:
  <hr class="s1" />
  <table><tbody><tr><td>0001</td><td>0001</td><td>0000</td><td>0000</td><td>0000</td><td>0000</td><td>0000</td><td>0101</td></tr></tbody></table>
  <hr class="s1" />
  Line 4:
  <hr class="s1" />
  <table><tbody><tr><td>0010</td><td>0001</td><td>0000</td><td>1000</td><td>1111</td><td>1111</td><td>1111</td><td>1111</td></tr></tbody></table>
  <hr class="s1" />
  Line 5:
  <hr class="s1" />
  <table><tbody><tr><td>1000</td><td>1101</td><td>0010</td><td>1011</td><td>0000</td><td>0000</td><td>0000</td><td>0000</td></tr></tbody></table>

q5_2: |
  b) Convert the following lines from machine code into their MIPS instruction.
  <hr class="s1" />
  Line 6: ______________________________
  <hr class="s1" />
  Line 8: ______________________________

q5_2_s: |
  Line 6: <code>add $t2 $t2 $t3</code>
  <hr class="s1" />
  Line 8: <code>j LabelB</code>

q5_3: |
  c) In a sentence or two, describe what this function does.

q5_3_s: |
  <b>Adds together the first $a0 elements of the array at $a1 and returns it into $v0.</b>

q6_1: |
  <h3>Q6: Mishmash, Hodgepodge, Potpourri (20 points)</h3>

  a)  Implement a function that only uses bitwise operations to return true if the most significant byte of
  a 16-bit unsigned integer is different from its least significant byte. For example, this function
  returns false for <code>0x1A1A</code> but true for <code>0x1A1B</code>. No conditionals or loops are permitted.

  <hr class="s2" />
  <code>
  int f( uint16_t n ) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;return ______________________________;
  <hr class="s1" />
  }
  </code>

q6_1_s: |
  <code>
  int f( uint16_t n ) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;return <b>((n >> 8) ^ n) & 0xFF</b>;
  <hr class="s1" />
  }
  </code>

q6_2: |
  b) What is the output of the following snippet of code? <code>%d</code> prints a signed integer and <code>%u</code> prints an unsigned integer.
  <hr class="s2" />

  <code>
  int main(){
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;int8_t x = -1;
  <hr class="s1"/>
  &nbsp;&nbsp;&nbsp;&nbsp;uint8_t y = 255;
  <hr class="s2"/>
  &nbsp;&nbsp;&nbsp;&nbsp;printf("===begin===\n");
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("i. %u\n", (uint8_t) x--);
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("ii. %u\n", (uint8_t) x);
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("iii. %u\n", ++y);
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("iv. %u\n", y);
  <hr class="s2" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("===break===\n");
  <hr class="s2" />
  &nbsp;&nbsp;&nbsp;&nbsp;uint8_t z = 255;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("v. %d\n", (int8_t) z);
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("vi. %u\n", (uint8_t) z);
  <hr class="s2" />
  &nbsp;&nbsp;&nbsp;&nbsp;z -= 256;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("vii. %d\n", z);
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;printf("===end===\n");
  <hr class="s1" />
  }
  </code>

  <hr class="s2" />
  <b>What is the output?</b>
  <hr class="s2" />
  ===begin===
  <hr class="s1" />
  i.
  <hr class="s1" />
  ii.
  <hr class="s1" />
  iii.
  <hr class="s1" />
  iv.
  <hr class="s1" />
  ===break===
  <hr class="s1" />
  v.
  <hr class="s1" />
  vi.
  <hr class="s1" />
  vii.
  <hr class="s1" />
  ===end===

q6_2_s: |
  ===begin===
  <hr class="s1" />
  i. <b>255</b>
  <hr class="s1" />
  ii. <b>254</b>
  <hr class="s1" />
  iii. <b>0</b>
  <hr class="s1" />
  iv. <b>0</b>
  <hr class="s1" />
  ===break===
  <hr class="s1" />
  v. <b>-1</b>
  <hr class="s1" />
  vi. <b>255</b>
  <hr class="s1" />
  vii. <b>255</b>
  <hr class="s1" />
  ===end===

q6_3: |
  c) Fill in the blank cells with the characteristics of each table:
  <hr class="s2" />
  <table>
  <thead><tr><th></th><th>Symbol Table</th><th>Relocation Table</th></tr></thead>
  <tbody>
  <tr><td>What phase(s) is it written to? Fill in with one of the CALL stages.</td><td></td><td></td></tr>
  <tr><td>What phase(s) is it read from? Fill in with one of the CALL stages.</td><td></td><td></td></tr>
  <tr><td>Why would you save a label into this table?</td><td></td><td></td></tr>
  </tbody>
  </table>

q6_3_s: |
  <table>
  <thead><tr><th></th><th>Symbol Table</th><th>Relocation Table</th></tr></thead>
  <tbody>
  <tr><td>What phase(s) is it written to? Fill in with one of the CALL stages.</td><td><b>Assembler</b></td><td><b>Assembler</b></td></tr>
  <tr><td>What phase(s) is it read from? Fill in with one of the CALL stages.</td><td><b>Linker</b></td><td><b>Linker</b></td></tr>
  <tr><td>Why would you save a label into this table?</td><td><b>Labels that can be used by other files</b></td><td><b>Labels needed by this file</b></td></tr>
  </tbody>
  </table>

q6_4: |
  d) The following questions refer to the job of the loader. Circle true or false.
  <hr class="s2" />
  i. &nbsp;&nbsp;&nbsp; True | False - Creates an address space for the program.
  <hr class="s1" />
  ii. &nbsp;&nbsp; True | False - Reads the object file to determine the size of text and data segments.
  <hr class="s1" />
  iii. &nbsp; True | False - Initializes all machine registers to 0.
  <hr class="s1" />
  iv. &nbsp;&nbsp; True | False - Copies the instructions from the executable file into the stack.
  <hr class="s1" />
  v. &nbsp;&nbsp;&nbsp; True | False - Is currently implemented as part of the OS.

q6_4_s: |
  i. &nbsp;&nbsp;&nbsp; <b>True</b>
  <hr class="s1" />
  ii. &nbsp;&nbsp; <b>False</b>
  <hr class="s1" />
  iii. &nbsp; <b>False</b>
  <hr class="s1" />
  iv. &nbsp;&nbsp;<b>False</b>
  <hr class="s1" />
  v. &nbsp;&nbsp;&nbsp;<b>True</b>
