course: 'cs61c'
ref: 'mt1-sp14'

type: 'mt1'
term: 'sp14'
prof: 'Garcia'
md: false

questions: {
  'q1': 'What''s that funky smell?! Oh yeah, it''s popourri..',
  'q2': 'Running in circles',
  'q3': 'Our band is called 1023MiB... We haven''t had any gigs yet.',
  'q4': 'A bad case of Not Invented Here Syndrome...',
}

parts: {
  'q1': 9,
  'q2': 3,
  'q3': 7,
  'q4': 1,
}

pre: |
  <div class="content-spacer"></div>

q1_1: |
  <h3>Q1: What’s that funky smell?! Oh yeah, it’s potpourri... (30 pts)</h3>
  a)  The unsigned distance between two bit patterns is
  the absolute value of the difference of their values,
  interpreted as unsigned numbers.  Rank the following
  according to the unsigned distance between -1 and 0
  (+0 if a representation has multiple zeros) in that
  representation. You should assign a rank of 1 to the
  representation with the <b><u>smallest</u></b> unsigned distance
  between -1 and 0.

  <hr class="s2" />
  int64_t:
  <hr class="s1" />
  64-bit One's Complement:
  <hr class="s1" />
  64-bit Sign and Magnitude:
  <hr class="s1" />
  64-bit Bias notation:
  <hr class="s1" />
  double:

q1_1_s: |
  int64_t: <b>5</b>
  <hr class="s1" />
  64-bit One's Complement: <b>4</b>
  <hr class="s1" />
  64-bit Sign and Magnitude: <b>2</b>
  <hr class="s1" />
  64-bit Bias notation: <b>1</b>
  <hr class="s1" />
  double: <b>3</b>

q1_2: |
  b)  As defined in IEEE 754-2008 standard, <u>half-precision floating point</u> (FP) is a 16-bit FP
  representation: 1 sign bit, 5 exponent bits, and 10 significand bits. The exponent bias of 15. What is the binary representation of the <i>smallest half-precision float which is strictly larger than 1</i>? What is its value? Leave your answer in terms of powers of two.
  <hr class="s2" />
  0b<code>______________________________</code> = <code>________</code>

q1_2_s: |
  0b <b>0&nbsp;&nbsp;&nbsp;01111&nbsp;&nbsp;&nbsp;0000000001</b> = <b>1 + $2^{-10}$</b>

q1_3: |
  c)  How would J-type instructions be affected (in terms of their “reach”) if we relaxed the requirement
  that instructions be placed on word boundaries, and instead required them to be placed on <i>half-word</i> boundaries.

q1_3_s: |
  The range over which we can jump would be cut in half.

q1_4: |
  d)  Building on the idea from the previous question, give a minor tweak to the MIPS ISA to allow us to
  use <i>true absolute addressing</i> (i.e., maximal “reach”) for all J-type instructions.

q1_4_s: |
  Only allow jumps to addresses which are multiples of $2^6$.

q1_5: |
  e)  Assume a request for 100 Bytes on either the <b>Stack</b> and <b>Heap</b> would succeed.
  In the worst case, <i>how many clock cycles</i> would it take to <b>allocate</b> 100 Bytes in each area & <i>why</i>?
  (“How many” should be answered with one of: {1, tens, thousands+})
  <hr class="s2" />
  <b>Stack:</b><code>________</code> because ______________________________
  <hr class="s1" />
  <b>Heap:</b><code>________</code> because ______________________________

q1_5_s: |
  <b>Stack:</b> <b>1</b> because <b>it's just addiu $sp $sp -100</b>.
  <hr class="s1" />
  <b>Heap:</b> <b>Thousands+</b> because <b>the freelist might contain lots of slivers to check</b>.

q1_6: |
  You have a program that can achieve almost a 20x speedup with millions of processors, so what is the percent of the parallel portion of its code?

q1_6_s: |
  95

q1_7: |
  g)  Suppose the assembler knew the file line numbers of all labels before it began its first pass over a

  file, and that every line in the file contains an instruction. Then the assembler would need <code>________</code>
  pass(es) to translate a MAL file, and <code>________</code> pass(es) to translate a TAL file. These numbers differ
  because of <code>______________________________</code> (write n/a if they don't differ).

q1_7_s: |
  2, 1, pseudoinstructions

q1_8: |
  Complete the code below, using <i>only one TAL instruction</i>, so that it returns true iff <b>$a0</b> is an I-type instruction or a J-type instruction, and then translate the instruction into binary then hexadecimal.
  <hr class="s2" />
  <code>
  IJ-instr: <code>________</code> -> 0b______________________________ -> 0x<code>________</code>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jr $ra
  </code>

q1_8_s: |
  <code>IJ-instr: <b>srl $v0 $a0 26</b></code>
  <hr class="s2" />
  <code>0b <b>0000|00 00|000 0|0100 0001|0 110|10 00|0010</b></code>
  <hr class="s2" />
  <code>0x <b>0004 1682</b></code>

q1_9: |
  What is one thing Google did to increase their Power Usage Efficiency (PUE)?

q1_9_s: |
  Careful airflow handling, elevated cold aisle temp, use free cooling, per-server ups.

q2_1: |
  <h3>Question 2: Running in circles (15 pts)</h3>
  a)  Recall the exercise <code><b>ll_cycle</b></code> from lab 2, in which we checked if a linked list contained a cycle using the tortoise and hare algorithm.  We’ve provided you with most of a simple <i>recursive</i> implementation in the space below. Fill in the base cases.

  <hr class="s2" />
  <code>
  int ll_has_cycle(node *ptr) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;if (!ptr)
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;return has_cycle(ptr, ptr->next);
  <hr class="s1" />
  }
  <hr class="s2" />
  int has_cycle(node *tortoise, node *hare) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;if (______________________________)
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;if (______________________________)
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;return has_cycle(tortoise->next, hare->next->next);
  <hr class="s1" />
  }
  </code>

q2_1_s: |
  <code>
  hare == tortoise
  <hr class="s1" />
  !hare || !hare->next
  </code>

q2_2: |
  b)  Now that you've warmed up on the C version of this code, let’s convert has_cycle into recursive MAL MIPS. Assume that the fields of the structs are not permuted from the struct definition. You may use fewer lines than we provide you, but do not add any more than the space provided.

  <hr class="s2" />
  <code>
  # $a0 contains the pointer to the tortoise.
  <hr class="s1" />
  # $a1 contains the pointer to the hare.
  <hr class="s2" />
  has_cycle: &nbsp;li $v0 1
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beq $a0 $a1 done
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li $v0 0
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beq __________ __________ done
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beq __________ __________ done
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addiu _______ _______ ________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addiu _______ _______ ________
  <hr class="s1" />
  done: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jr return a
  </code>

q2_2_s: |
  <code>
  # $a0 contains the pointer to the tortoise.
  <hr class="s1" />
  # $a1 contains the pointer to the hare.
  <hr class="s2" />
  has_cycle: &nbsp;li $v0 1
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beq $a0 $a1 done
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li $v0 0
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beq <b>$a1</b> <b>$0</b> done
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>lw $a1 4($a1)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beq <b>$a1</b> <b>$0</b> done
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>lw $a0 4($a0)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>lw $a1 4($a1)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addiu <b>$sp</b> <b>$sp</b> <b>-4</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>sw $ra 0($sp)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>jal has_cycle</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>lw $ra 0($sp)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addiu <b>$sp</b> <b>$sp</b> <b>4</b>
  <hr class="s1" />
  done: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jr $ra
  </code>

q2_3: |
  c) You want to change this to be an <i>iterative</i> MIPS solution, but you want to <i>change the fewest lines</I> you can. Circle those lines you would change to make the program work <i>iteratively</i>.

q2_3_s: |
  <code>
  # $a0 contains the pointer to the tortoise.
  <hr class="s1" />
  # $a1 contains the pointer to the hare.
  <hr class="s2" />
  has_cycle: &nbsp;li $v0 1
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beq $a0 $a1 done
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li $v0 0
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beq <b>$a1</b> <b>$0</b> done
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>lw $a1 4($a1)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beq <b>$a1</b> <b>$0</b> done
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>lw $a0 4($a0)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>lw $a1 4($a1)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addiu <b>$sp</b> <b>$sp</b> <b>-4</b> &nbsp;<i><- circled, changed to nop</i>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>sw $ra 0($sp)</b> &nbsp;&nbsp;&nbsp; <i><- circled, changed to nop</i>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>jal has_cycle</b> &nbsp;&nbsp;&nbsp; <i><- change to j has_cycle</i>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>lw $ra 0($sp)</b>
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addiu <b>$sp</b> <b>$sp</b> <b>4</b>
  <hr class="s1" />
  done: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jr $ra
  </code>

q3_1: |
  <h3>Question 3: Our band is called 1023MiB... We haven’t had any gigs yet. (15 pts)</h3>

  We have a standard 32-bit byte-addressed MIPS machine with a 1KiB direct-mapped write-back
  cache and 16B block size.
  <hr class="s2" />

  a)  How many bits are used for the:
  <hr class="s1" />
  Tag? <code>________</code>
  <hr class="s1" />
  Index? <code>________</code>
  <hr class="s1" />
  Offset? <code>________</code>

q3_1_s: |
  Tag: <b>22</b>
  <hr class="s1" />
  Index: <b>6</b>
  <hr class="s1" />
  Offset: <b>4</b>

q3_2: |
  Consider the following C code, and answer the questions below. <code><b>d</b></code> and <code><b>s</b></code> are pointers to 8-bit unsigned integer arrays, of the same size (a multiple of the cache size) that are aligned on 16-byte
  boundaries. The arrays contain only one <code><b>0x00</b></code>, in the last byte.<code><b>d</b></code> and <code><b>s</b></code> are not necessarily distinct.

  <hr class="s2" />

  <code>
  void our_strcpy(uint8_t *d, uint8_t *s) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;char c;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;do {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c = *s;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*d = c;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s++; d++;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;} while (c);
  <hr class="s1" />
  }
  </code>

  <hr class="s2" />
  b) What is the <i>lowest</i> possible cache hit rate for <code><b>our_strcpy</b></code>?

q3_2_s: |
  <b>0</b>

q3_3: |
  c) What <i>types</i> of misses are there?

q3_3_s: |
  <b>Compulsory and conflict</b>

q3_4: |
  d) What is the <i>smallest possible</i> value of <code>(d - s)</code> that would get this hit rate?

q3_4_s: |
  <b>1 KiB</b>

q3_5: |
  e) What is the <i>highest</i> possible cache hit rate for <code><b>our_strcpy</b></code>?

q3_5_s: |
  <b>31/32</b>

q3_6: |
  f) What is one possible value of <code><b>(d - s)</b></code> where we would get this hit rate?

q3_6_s: |
  <h3>0</h3>
  <hr class="s1" />
  <i>2 misses per block * 2^6 blocks/cache * 2^13 caches = 2^20 misses</i>

q3_7: |
  g) If we ran <code><b>our_strcpy</b></code> with a 4-way set-associative LRU cache, and the sizes of both <code><b>d</b></code> and <code><b>s</b></code> are 8MiB, what is the <i>most # of misses</i> possible?

q3_7_s: |
  <b>1 Mebi</b>

q4_1: |
  <h3>Question 4: A bad case of Not Invented Here Syndrome... (15 pts)</h3>
  <hr class="s1" />
  a) A colleague of yours has implemented some homebrew C99 string manipulation functions, while

  steadfastly refusing to use any standard libraries, but they’re buggy!  We've marked each
  potentially problematic line with <code>// <number></code>.  Your job is to fill in a correct replacement line in the
  corresponding row of the following table, or write <i>'OK' if there is nothing wrong</i>.  DO NOT LEAVE ANY FIELDS BLANK, or we will assume you just didn't get to this part of the exam.

  <hr class="s2" />

  <table>
  <thead><tr><th width="2">Line number</th><th>Replacement Code</th></tr></thead>
  <tbody>
  <tr><td>1</td><td></td></tr>
  <tr><td>2</td><td></td></tr>
  <tr><td>3</td><td></td></tr>
  <tr><td>4</td><td></td></tr>
  <tr><td>5</td><td></td></tr>
  </tbody>
  </table>

  <hr class="s2" />

  <code>
  /** Converts the string S to lowercase */
  <hr class="s1" />
  void string_to_lowercase(char *s) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;for (char c = *s; c != '\0'; s++) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 1
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (c >= 'A' && c <= 'S') {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s += 'a' - 'A';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 2
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <hr class="s1" />
  }
  <hr class="s2" />
  /** Returns the number of bytes in S before, but not counting, the null terminator. */
  <hr class="s1" />
  size_t string_length(char *s) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;char *s2 = s;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;while (*s2++); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;return s2 - s - 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4
  <hr class="s1" />
  }
  <hr class="s2" />
  /** Return the number of odd numbers in a number array */
  <hr class="s1" />
  uint32_t number_odds(uint32_t *numbers, uint32_t size) {
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;uint32_t odds = 0;
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;for (uint32_t i = 0; i < size; i++)
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;odds += *numbers+i && 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 5
  <hr class="s1" />
  &nbsp;&nbsp;&nbsp;&nbsp;return odds;
  <hr class="s1" />
  }
  </code>

q4_1_s: |
  <table class="special-table">
  <thead><tr><th width="1">Line number</th><th>Replacement Code</th></tr></thead>
  <tbody>
  <tr><td>1</td><td><code>for (char c = *s; (c = *s) != '\0'; s++) {</code></td></tr>
  <tr><td>2</td><td><code>*s += 'a' - 'A';</code></td></tr>
  <tr><td>3</td><td><code>OK</code></td></tr>
  <tr><td>4</td><td><code>OK</code></td></tr>
  <tr><td>5</td><td><code>odds += numbers[i] & 1&nbsp;&nbsp;...&nbsp;&nbsp;odds += *(numbers+i) & 1</code></td></tr>
  </tbody>
  </table>