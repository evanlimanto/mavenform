course: 'cs162'
ref: 'mt1-fa16'

type: 'mt1'
term: 'fa16'
prof: 'Joseph'

questions: {
  'q1': 'True/Fase and Why?',
  'q2': 'Deadlock',
  'q3': 'Memory Management',
  'q4': 'Scheduling',
}

parts: {
  'q1': 8,
  'q2': 6,
  'q3': 6,
  'q4': 6,
}

q1_1: |
  # 1. (27 points total) True/False and Why?
  ## a. (12 points) True/False and Why? CIRCLE YOUR ANSWER.
  i) It is possible for a FCFS scheduler to achieve a lower average turnaround time (the time a process takes to complete after it arrives) than a Round Robin scheduler, even if you assume there is no context switching overhead. **(TRUE/FALSE)**

q1_1_s: |
  **True.** Three examples: cache is shared with Round Robin, not FCFS; the jobs could arrive in order shortest to largest, reducing FCFS to SRTF; jobs could all be the same length, with that length being longer than the RR quanta. The correct answer was worth 1 point and the justification was worth an additional 2 points.

q1_2: |
  ii) 8MB 2-way set-associative cache with a Most Recently Used (MRU) replacement policy will always have better or equal cache performance when compared to a 4MB direct-mapped cache.

q1_2_s: |
  **True.** A larger cache and higher degree of associativity cache will have a higher hit rate than a smaller direct cache (fewer capacity and conflict misses). The correct answer was worth 1 points and the justification was worth an additional 2 points.

q1_3: |
  iii) Suppose we have a multithreaded process that accesses (reads and writes) to an external database, and it avoids race conditions by having each thread acquire a lock global variable before accessing the database. Using this approach, we can run two instances of this process accessing the same database at the same time.

q1_3_s: |
  **FALSE.** A lock in one process instance will not affect the other process. The correct answer was worth 1 points and the justification was worth an additional 2 points.

q1_4: |
  iv) If the Banker’s algorithm will not approve a resource request, and the resource request is processed, then system necessarily will enter deadlock.

q1_4_s: |
  **FALSE.** Banker’s algorithm only guarantees that a system is in a safe state. If a system is in an unsafe state, deadlock may or may not occur. The correct answer was worth 1 points and the justification was worth an additional 2 points.

q1_5: |
  ## b. (15 points) Short answer.
  i) (4 points) <u>Briefly</u>, in two to three sentences, explain how having a combination
  of I/O-bound processes and CPU-bound processes maximizes system utilization.

q1_5_s: |
  We want to keep all parts of the system busy, so if you can have some processes using the CPU while others wait on I/O, then the system will be more utilized. In general, systems are underutilized (there are a lot of wasted cycles both on I/O devices as well as CPU).

q1_6: |
  ii) (4 points) <u>Briefly</u>, in two to three sentences, explain how given a set of jobs and their arrival and execution times, you could quickly (O(n) time) determine if FCFS would produce a schedule that is optimal in terms of average completion time.

q1_6_s: |
  If the arrival order and execution times would yield a FCFS schedule that is identical to SRTCF, then the FCFS schedule would be optimal.

q1_7: |
  iii) (4 points) <u>Briefly</u>, in two to three sentences, explain when a hard real-time scheduling system, such as Earliest Deadline First, will **not** be able to meet all deadlines.

q1_7_s: |
  If more tasks are submitted than the system has resources, then EDF will be
  unable to provide a schedule that meets deadlines.

q1_8: |
  iv) (3 points) Early Intel processors such as the 8086 did not support dual-mode operation. <u>Briefly</u>, in two to three sentences, explain whether you can or cannot implement virtual memory and address spaces on such systems. If so, explain how. If not, explain why not.

q1_8_s: |
  No, special instructions are unprotected and any process could change address translation information. We also accepted a yes answer if you clearly explained how a virtual machine could be used to emulate the behavior of dual mode operation.

q2_1: |
  # 2. (30 points total) Deadlock.
  a. (8 points) What are the four requirements for deadlock? Provide a brief <u>one sentence</u> explanation of each requirement.

q2_1_s: |
  - Mutual exclusion: at least one resource must be held in a non-sharable  mode.
  - Hold and wait: a process must be holding at least one resource and  waiting to acquire additional resources that are currently being held by  other processes.
  - No preemption: a resource can be released only voluntarily by the  process holding it.
  - Circular wait: A set $\\{P_0, P_1, ..., P_n\\}$ of waiting process must exist such that  $P_0$ is waiting for a resource held by $P_1, P_1$ is waiting for a resource held by $P_2, ... P_{n-1}$ is waiting for a resource held by $P_n$, and $P_n$ is waiting for a resource held by $P_0$.

q2_2: |
  b. (6 points) Consider the following resource allocation policy:
  <hr class="s1" />
  Requests for and releases of resources are allowed at any time. If a request for resources cannot be satisfied because the resources are not available, then we check any processes that are blocked, waiting for resources. If they have the desired resources, then these resources are taken away from them and are given to the requesting process. The vector of resources for which the waiting process is waiting is increased to include the resources that were taken away. If the resources needed by a blocked process become available, the process is put back on the ready queue.
  <hr class="s2" />
  For example, consider a system with three resource types and the vector `Available` initialized to (4,2,2).
  - If process `P0` asks for (2,2,1), it gets them.
  - If `P1` asks for (1,0,1), it gets them.
  - Then, if `P0` asks for (0,0,1), it is blocked (resource not available).
  - If `P2` now asks for (2,0,0), it gets the available one (1,0,0) and one that
  was allocated to `P0` (since `P0` is blocked). `P0`’s `Allocation` vector goes down to (1,2,1), and its `Need` vector goes up to (1,0,1).

  <hr class="s2" />
  ii) With this resource allocation policy, can deadlock occur? If so, give an example. If not, which necessary condition cannot occur?

q2_2_s: |
  Deadlock cannot occur because preemption exists, which removes one of the preconditions for deadlock.

q2_3: |
  iii) Can starvation occur?

q2_3_s: |
  Yes. A process may never acquire all the resources it needs if they are continuously preempted by a series of requests.

q2_4: |
  c. (7 points total) Consider a monitor implemented as follows:

  ```
  condition p, q; // p and q are initialized for you
  lock mutex = FREE;

  void stop(void) {
      ......
      p.wait(&mutex);
      ......
      q.signal();
  }

  void go(void) {
      ......
      p.signal();
      q.wait(&mutex);
  }
  ```

  Suppose two processes `P1` and `P2` use the monitor in the following way:
  ```
  <b>P1:</b>
  while (TRUE) {
      ......
      stop();
      ......
  }

  <b>P2:</b>
  while (TRUE) {
      ......
      go();
      ......
  }
  ```

  (i) (5 points) Show that deadlock can occur by listing an execution sequence ending in deadlock with explanation for each step. *Only one process can run at a time at each step* – **you do not have to fill in all the rows below.**
  <hr class="s2" />
  ![table](/img/cs162/mt2-fa16-q2-1.png)

q2_4_s: |
  ![table](/img/cs162/mt2-fa16-q2-2.png)
  <hr class="s2" />
  Now, `P1` is waiting for `P2`’s signal (i.e., p.signal) and `P2` is waiting for `P1`’s signal (i.e., q.signal). Thus, we have a circular waiting, and, hence a deadlock..

q2_5: |
  ii) (2 points) Can starvation occur?

q2_5_s: |
  Yes. Deadlock implies starvation.

q2_6: |
  d. (9 points) There are 5 lawyers sitting at a round dinner table. Lawyers repeat (forever) the following three things in order: (1) think, (2) eat, and (3) sleep. Each lawyer has a bowl of rice in front of them and a chopstick between each plate.
  <hr class="s1" />
  **A lawyer must have two chopsticks to be able to eat!** A lawyer can only acquire the chopstick to the left of their plate and the chopstick to the right of their plate; they cannot reach across the table to use other chopsticks. When they are done eating, they put down (release) the two chopsticks for someone else to use. Below is code that attempts to solve this problem. Each lawyer will call this method with the parameter (0 to 4) indicating the lawyer’s seat number. **Unfortunately, this code can deadlock.**
  <hr class="s1" />
  *Your task is to fix this code so it cannot get stuck and so that more than one lawyer can eat at the same time* – **your solution cannot use any other synchronization primitives.**
  <hr class="s2" />
  The constructor is called once in the main function, and then $5$ lawyer threads are created, each one executing the `Go()` method. `Think()`, `Eat()`, and `Sleep()` are already written and you don’t know how long they take to run.

  ```
  Lawyers() {
      for (int i=0; i<=4; i++) chopstick[i] = new Semaphore(1);
  }
  void Go(int p) {
      while (1) {
          Think();



          chopstick[p].P();
          chopstick[(p + 1) % 5].P();



          Eat();
          chopstick[p].V();
          chopstick[(p + 1) % 5].V();
          Sleep();
      }
  }
  ```

q2_6_s: |
  ```
  Lawyers() {
      for (int i=0; i<=4; i++) chopstick[i] = new Semaphore(1);
  }
  void Go(int p) {
      while (1) {
          Think();
          // By having every other philosopher
          // get the chopsticks in the opposite
          // order, we break the cycli dependency
          if (p%2 == 0) {
              // Grab left, then grab right

              chopstick[p].P();
              chopstick[(p + 1) % 5].P();

          } else {
              //---Grab right, then grab left
              chopstick[(p + 1) % 5].P();
              chopstick[p].P();
          }
          Eat();
          chopstick[p].V();
          chopstick[(p + 1) % 5].V();
          Sleep();
      }
  }
  ```

  Note that we accepted any solution in which at least one lawyer acquired the chopsticks in reverse order also was correct.

q3_1: |
  # 3. (25 points total) Memory Management.
  a. (12 pts) Consider the following string of memory references in terms of requested
  page number: $1, 2, 3, 4, 5, 3, 4, 1, 6, 7, 8, 7, 8, 9, 7, 8, 9, 5, 4, 5, 4, 2.$
  <hr class="s2" />
  Fill in the table below with using the FIFO, MIN and LRU (Least Recently Used) page replacement algorithms for memory with five frames by filling in the table with page numbers. The top row is the string of memory references, and each row contains the page numbers that reside in each physical frame $F1$ – $F5$ after each memory reference. For readability purposes, please only fill in the table entries that have changed and leave the unchanged entries blank. If several pages meet the replacement criteria, replace the one with the smallest frame number.
  i) FIFO
  <hr class="s2" />
  ![table](/img/cs162/mt2-fa16-q3-1.png)
  <hr class="s2" />
  What is the number of page faults, including compulsory faults?

q3_1_s: |
  ![table](/img/cs162/mt2-fa16-q3-4.png)
  <hr class="s2" />
  What is the number of page faults, including compulsory faults? **12**

q3_2: |
  ii) MIN
  <hr class="s2" />
  ![table](/img/cs162/mt2-fa16-q3-2.png)
  <hr class="s2" />
  What is the number of page faults, including compulsory faults?

q3_2_s: |
  ![table](/img/cs162/mt2-fa16-q3-5.png)
  <hr class="s2" />
  What is the number of page faults, including compulsory faults? **10**

q3_3: |
  ii) LRU
  <hr class="s2" />
  ![table](/img/cs162/mt2-fa16-q3-3.png)
  <hr class="s2" />
  What is the number of page faults, including compulsory faults?

q3_3_s: |
  ![table](/img/cs162/mt2-fa16-q3-6.png)
  <hr class="s2" />
  What is the number of page faults, including compulsory faults? **12**

q3_4: |
  b. (4 points) Some operating systems provide a virtual copy operation:
  ```
  VirtualCopy(proc, addr1, addr2, len),
  ```
  where data of length `len` starting at location `addr1` in the caller’s address space is “copied” to process `proc`’s address space starting at location `addr2`. Assume that `addr1`, `addr2`, and `len` are multiples of the page size. Assuming a page-table-based virtual memory system, explain how we can efficiently implement `VirtualCopy` so as to minimize the amount of copying required. *Note that after `Virtual Copy` completes, the two processes will **not** share writes to the data.*

q3_4_s: |
  We could use copy-on-write: the page-table entries for the pages of the source (in the calling process starting at location `addr1` for `len` bytes) is copied into page table entries for process proc’s address space starting at location `addr2`. The pages are marked “copy on write” (if not done so already) and their reference counts are incremented by one (they would of course start at one when the pages are first allocated). The page-table entries in both processes are marked read- only. Now, while both processes merely read the pages, they continue to share them. But if either process attempts to modify the page, the attempt is trapped by the OS, a new page is allocated and the old is copied into it, the page table entry for the modifying process is set to point to the new page and is set to read-write with a reference count of $1$, and the reference count of the original page is decremented by $1$. If this reference count is now zero, its (single) page-table entry is changed to read-write.

q3_5: |
  c. (9 points total) Inverted Page Tables. Assume we have a simple, demand paging environment, with no segmentation. Processes `P1` and `P2` both have logical memory addresses in the range $0 . . . 99$, inclusive. The page size is $5$. The hash table portion of the structure uses a hash function which simply calculates the index by adding the numerical portion of the process identifier and the logical page number. Note that this is a really bad hash function because it requires a large hash table, but for our exercise, it is sufficient. The hash table and the inverted page table shown are below.
  <hr class="s2" />
  ![table](/img/cs162/mt2-fa16-q3-7.png)
  <hr class="s2" />
  Arrows in the hash table indicate chaining of entries when a hash conflict has occurred. Empty entries in the IPT indicate the associated physical frames are not allocated.
  <hr class="s2" />
  i) (6 points) Calculate the physical addresses for the following logical addresses where the number after the colon is the logical address (**not the logical page**). Assume the first page of a process is page number $0$, and that a mechanism exists to find a free frame in memory.
  <hr class="s1" />
  *Show your work for these calculations for partial credit – what calculations and table lookups were necessary to determine the actual address in memory from the logical address.*
  <hr class="s2" />
  (1) P1:17
  <hr class="s2" />
  (2) P1:92
  <hr class="s2" />
  (3) P1:111

q3_5_s: |
  (1) P1:17
  <hr class="s1" />
  Logical page $17/5 = 3$ offset = $2$. hash table index = $3 + 1$, follow chain to entry $5$. From lookup, logical frame = $4$. Address = (frame)∗(frame size) + offset = $4 ∗ 5 + 2$ = $22$
  <hr class="s2" />
  (2) P1:92
  <hr class="s1" />
  Logical page = $18$. offset = $2$. Hash table index = $19$. From lookup logical frame = $3$. Address = $17$
  <hr class="s2" />
  (3) P1:111
  <hr class="s1" />
  Exception, memory reference out of range.

q3_6: |
  ii) (3 points) When process `P2` attempts to read logical address $97$, what happens? Specifically, describe the changes in the data structures, and what the process perceives of these changes.

q3_6_s: |
  This causes a page fault. Frame $0$ is allocated, and the entry in the IPT is updated with the logical address information for `P2` frame $19$. Next the hashtable entry at index $21 (19 + 2)$ is mapped from `P2:19` to frame $0$. After this processing is complete, the `P2` resumes execution as before.

q4_1: |
  # 4. (18 points total) Scheduling. Five processes $A, B, C, D$ and $E$ arrive in this order at the same time with the following CPU bursts.
  <hr class="s2" />
  ![table](/img/cs162/mt2-fa16-q4-1.png)
  <hr class="s2" />
  Fill in the entries of the following table with turnaround times and total turnaround time for each indicated scheduling policy and each process. Ignore context switching overhead. Turnaround time is defined as the time a process takes to complete after it arrives.
  <hr class="s2" />
  ![table](/img/cs162/mt2-fa16-q4-2.png)

q4_1_s: |
  ![table](/img/cs162/mt2-fa16-q4-3.png)
