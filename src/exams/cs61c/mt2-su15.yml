course: 'cs61c'
ref: 'mt2-su15'

type: 'mt2'
term: 'su15'
prof: 'Karandikar'

questions: {
  'q1': 'Potpourri',
  'q2': 'Pipelining',
  'q3': 'Synchronous Digital Systems',
  'q4': 'Datapath',
  'q5': 'Caches',
}

parts: {
  'q1': 5,
  'q2': 2,
  'q3': 3,
  'q4': 7,
  'q5': 4,
}

q1_1: |
  # Q1. Potpourri (12 pts)
  a) Convert the following from single-precision IEEE 754 representation to decimal: `0xFF800000`

q1_1_s: |
  -inf

q1_2: |
  b) Convert the following from decimal to single-precision IEEE 754 representation. <u>Report your answer as hex:</u> `-10.5625`

q1_2_s: |
  `0xC1290000`

q1_3: |
  The following sub-questions will use the circuit below.
  ![circuit](/img/cs61c/mt2-su15-q1-1.png)
  Circuit specs:
  - 15 ns clk-to-Q time
  - Negligible hold time
  - 20 ns logical gate propagation delay
  - Gates with bubbles on the output have the same delay as “normal” gates
  - Assume that X and Y arrive at the positive edge of the clock

  <hr class="s2" />
  Given Circuit A, with a clock period of 100ns, determine the maximum theoretical setup time we can have for this circuit to satisfy register-timing constraints (and function correctly). With this setup time, if signals X and Y are undefined until t = 0, when would Out1 be stable with the correct computed value?
  <hr class="s1" />
  c) Max setup time:

q1_3_s: |
  `60ns = 100 – MAX(CriticalPath1 + CriticalPath2)`

q1_4: |
  d) Out1 stable at t =

q1_4_s: |
  `215ns = 2 clock cycles + CLK-to-Q`

q1_5: |
  e) We discover that our registers are faulty and have a 30ns hold time requirement. Assuming a setup time of 15ns and other timing parameters from the parts (a) and (b), is this a problem? If it is, suggest the simplest change that could be made so the circuit behaves as intended.
  
q1_5_s: |
  There are hold time violations in the two middle registers. One solution
  is to delay the inputs X and Y for at least 10ns. This can be done by
  adding an OR gate to each signal with the signal and a constant 1 as
  inputs.

q2_1: |
  # Q2. Pipelining (17 pts)
  a) Below is a copy of the diagram from the previous question. Now, you need to pipeline the circuit to improve the clock period. <u>**Draw a star on any wire where you would place a pipelining register.**</u> You may place up to 3 registers (but you may not need all 3). Your solution may introduce a cycle delay, but should not change the sequence of outputs after that initial delay (assuming the circuit gets a single uninterrupted stream of incoming X and Y values).
  ![circuit](/img/cs61c/mt2-su15-q2-1.png)
  Circuit specs:
  - 15 ns setup time
  - 15 ns clk-to-Q time
  - Negligible hold time
  - 20 ns logical gate propagation delay
  - Gates with bubbles on the output have the same delay as “normal” gates
  - Assume that X and Y arrive at the positive edge of the clock

  ![circuit](/img/cs61c/mt2-su15-q2-1.png)

q2_1_s: |
  ![circuit](/img/cs61c/mt2-su15-q2-2.png)

q2_2: |
  b) Now, assume we have a Pipelined 5-stage MIPS CPU with the following specs:
  - The CPU stalls on hazards, there is no forwarding
<<<<<<< HEAD
  - Branch comparison happens in stage 2 and we DO NOT have a branch delay slot. (i.e. the branch “decision” is clocked into the PC at the end of stage 2).
  - Both memory and registers CAN be written and read in the same clock cycle
=======
  - Branch comparison happens in stage 2 and we **DO NOT** have a branch delay slot. (i.e. the branch “decision” is clocked into the PC at the end of stage 2).
  - Both memory and registers **CAN** be written and read in the same clock cycle
>>>>>>> master
  - All Loads and Stores hit in the cache (ie. loads/stores take one cycle in the Mem stage)

  <hr class="s2" />
  Fill in the corresponding pipeline stages (F, D, E, M, W) at the appropriate times in the table below for the following 8 MIPS instructions assuming the table properties of your CPU. Suppose that any branches in the code are not taken for this specific instance. (You should use the back of the page for scratch work)
  ![table](/img/cs61c/mt2-su15-q2-3.png)

q2_2_s: |
  ![table](/img/cs61c/mt2-su15-q2-4.png)

q3_1: |
  # Q3. Synchronous Digital Systems (11 pts)
  Use the truth table below for the following questions:
  ![truth table](/img/cs61c/mt2-su15-q3-1.png)
  a) Write a Boolean formula for **next_st0** <u>using sum of products</u>. You should not simplify the expression you write. (Also, do not write a solution that you get “intuitively”).

q3_1_s: |
  `(~st0 * ~st1 * ~In)+(~st0 * st1 * In)`

q3_2: |
  b) Use the circuit below to fill in next_st1 in the truth table.
  ![circuit](/img/cs61c/mt2-su15-q3-2.png)

q3_2_s: |
  ![truth table](/img/cs61c/mt2-su15-q3-3.png)

q3_3: |
  c) Simplify the following expression so it can be implemented with 3 basic gates (AND, OR, or NOT). Your solution should require as few gates as possible. You do not need to fill in the table above.
  ![equation](/img/cs61c/mt2-su15-q3-4.png)

q3_3_s: |
  `~(In+st0st1)`

q4_1: |
  # Q4. Datapath (20 pts)
  Given the new instruction beqalr represented by the RTL below, answer the following questions.
  ![code](/img/cs61c/mt2-su15-q4-1.png)
  a) Briefly describe what we would use this instruction for in a program. (Hint: think about what C code that gets compiled into this instruction would look like.)

q4_1_s: |
<<<<<<< HEAD
  <u>We could use this instruction for conditional function calls.</u> This is better than a simple branch because it is not constrained by the address range 2^17-4 lower to 2^17 higher.

q4_2: |
  b) Write equivalent TAL MIPS for the **beqalr** instruction. `\$ra` should be set to the instruction after the expanded **beqalr** (labeled "**resume**"). **Our system does not have delay slots.**
=======
  <u>We could use this instruction for conditional function calls.</u> This is better than a simple branch because it is not constrained by the address range $2^{17}-4$ lower to $2^{17}$ higher.

q4_2: |
  b) Write equivalent TAL MIPS for the **beqalr** instruction. `$ra` should be set to the instruction after the expanded **beqalr** (labeled "**resume**"). **Our system does not have delay slots.**
>>>>>>> master
  ![code](/img/cs61c/mt2-su15-q4-2.png)

q4_2_s: |
  ![code](/img/cs61c/mt2-su15-q4-3.png)

q4_3: |
  c) Now we want to modify our pipeline so that it is able to execute the **beqalr** instruction. Below (and attached to the green sheet), you will find a base CPU diagram with empty boxes. For each missing piece in the datapath, <u>circle which options on the next page are the best in implementing</u> **beqalr**. If there are multiple working solutions, **choose the one with the least hardware**. The control signal for **beqalr** is 1 if and only if the instruction is **beqalr**. **RegWr** is **0**.
  ![hardware](/img/cs61c/mt2-su15-q4-4.png)
  i) We have the ability to modify our RegFile. Which modification is necessary for our implementation?
  ![hardware](/img/cs61c/mt2-su15-q4-5.png)

q4_3_s: |
  4. RegWr is off. We can only write if the condition is fulfilled.

q4_4: |
  ii) Select the correct modification for box (ii)
  ![hardware](/img/cs61c/mt2-su15-q4-6.png)

q4_4_s: |
  1. Our RegDst should be $ra (0b11111) if we are executing a beqalr instruction.

q4_5: |
  iii) Select the correct modification for box (iii)
  ![hardware](/img/cs61c/mt2-su15-q4-7.png)

q4_5_s: |
  1. Our WriteEn is taken care of. If our instruction is beqalr, we need to be writing PC+4 into our destination.

q4_6: |
  iv) Select the correct modification for box (iv)
  ![hardware](/img/cs61c/mt2-su15-q4-8.png)

q4_6_s: |
  2. If our condition is fulfilled, we want to overwrite our PC with our \$rd read value.

q4_7: |
  d) Generate the control signals for `beqal`. The values should be 0, 1, or X (don’t care) terms. You must use don’t care terms where possible.
  ![table](/img/cs61c/mt2-su15-q4-9.png)

q4_7_s: |
  ![table](/img/cs61c/mt2-su15-q4-10.png)

q5_1: |
  # Q5. Caches (17 pts)
  Assume we are working in a 32-bit physical address space. We have two possible data caches: cache X is a direct-mapped cache, while cache Y is 2-way associative with LRU replacement policy. Both are 4 KiB caches with 512 B blocks and use write-back and write-allocate policies.
  <hr class="s2" />
  a) Calculate the number of bits used for Tag, Index and Offset:
  ![table](/img/cs61c/mt2-su15-q5-1.png)

q5_1_s: |
  ![table](/img/cs61c/mt2-su15-q5-2.png)

q5_2: |
  Use the code below to answer the following parts. Assume that ints are 4 B and doubles are 8 B.

  ```
  int DOUBLE_ARRAY_SIZE = 2 * 1024;
  double double_arr[DOUBLE_ARRAY_SIZE];


  for (int i = 0; i < DOUBLE_ARRAY_SIZE; i++) /* loop 1 */
      double_arr[i] = i;

  for (int i = 0; i < DOUBLE_ARRAY_SIZE; i += 8) /* loop 2 */
      double_arr[i] *= double_arr[0];
  ```

  b) What is the hit rate for each cache if we run only loop 1? (hint: they’re both the same). What types of misses do we get?

q5_2_s: |
  Both have a hit rate of 63/64. Compulsory.

q5_3: |
  c) What is the hit rate of each cache when you execute loop 2? Assume that you have executed loop 1. Assume the worst case ordering of accesses within a single iteration of the loop if multiple orders are possible. You may leave your answer as an expression involving products and sums of fractions.
  <hr class="s2" />
  X: __________________________________ &nbsp;&nbsp; Y: __________________________________

q5_3_s: |
  We are accessing with a stride of 8*8B = 64B while our block size is 512B.
  Thus, we have 8 accesses in each block. Since the array size is 2Ki*8B =
  16KiB and our caches are 4KiB, the actual data is 4 times the size of our
  caches.
  <hr class="s2" />
  In cache X, the first quarter of the array will have a hit rate of 23/24 since we only encounter misses in each new block. In the rest of the array, however, we get a ping-pong effect on the first block as the loop requires double_arr[0]. For the 2nd-4th quarter of the array, the first block
  accesses will be (double_arr[i], double_arr[0], double_arr[i]):
  <hr class="s1" />
  Access 1: M, M, M
  <hr class="s1" />
  Access 2: H, M, M
  <hr class="s1" />
  Access 3: H, M, M; then H, M, M until access 8.
  <hr class="s1" />
  This yields a hit rate of 7/24. The second through eighth block accesses have 23/24 hit rate.
  <hr class="s2" />
  Putting it all together, since we are accessing 4*8 blocks in total,
  Hit rate = 29/32 * 23/24 + 3/32 * 7/24
  <hr class="s2" />
  Cache Y has a hit rate of 23/24 because there is no ping-pong effect in
  the first block.

q5_4: |
  d) Compute the AMAT for the following system with 3 levels of caches. (You should not need any information from the previous parts of this problem.) <u>Give your answer as a decimal value.</u>
  ![table](/img/cs61c/mt2-su15-q5-3.png)

q5_4_s: |
<<<<<<< HEAD
  `1 + .5*(5 + .20*(15 + .01*(500))) = 5.5 ns`
=======
  `1 + .5*(5 + .20*(15 + .01*(500))) = 5.5 ns`
>>>>>>> master
