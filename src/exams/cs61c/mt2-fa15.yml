course: 'cs61c'
ref: 'mt2-fa15'

type: 'mt2'
term: 'fa15'
prof: 'Stojanovic, Wawrzynek'

questions: {
  'q1': 'Let''s Adder All Up',
  'q2': 'Datapathology',
  'q3': 'Hazardous Conditions',
  'q4': 'Cache Rules Everything Around Me',
  'q5': 'Don''t Let Your Mind Float Away Now',
}

parts: {
  'q1': 4,
  'q2': 7,
  'q3': 3,
  'q4': 4,
  'q5': 3,
}

q1_1: |
  # Q1: Let's Adder All Up (15 points)
  Consider the 4-bit adder shown to the right
  <hr class="s1" />
  It takes:
  - a carry in (cin)
  - two four-bit inputs:
    - a with bits a0, a1, a2, a3
    - b with bits b0, b1, b2, b3

  <hr class="s2" />
  Outputs:
  - a carry out (cout)
  - one four-bit output:
    - s with bits s0, s1, s2, s3

  <hr class="s2" />
  Assume each adder has a delay of 10ns, and any registers have a clk-to-q, hold time, and setup time of 5ns. Assume the inputs are driven by registers, and outputs are registers as well.
  <hr class="s2" />
  Assume each adder has a delay of 10ns, and any registers have a clk-to-q, hold time, and setup time of 5ns. Assume the inputs are driven by registers, and outputs are registers as well.
  <hr class="s2" />
  1. Write Boolean formulas for `s0` and `c1` in terms of the inputs `cin, a0`, and `b0`. You may use XOR as an operator in the Boolean formulas. Each formula should use as few operators as possible.
  ![circuit](/img/cs61c/mt2-fa15-q1-1.png)
  s0 = ________________________________
  <hr class="s2" />
  c1 = ________________________________

q1_1_s: |
  `s0 = a0 XOR b0 XOR cin`
  <hr class="s1" />
  `c1 = cin * (a0 XOR b0) + a0 * b0`

q1_2: |
  2. What is the critical path delay of the circuit? Please include proper units in your answer.

q1_2_s: |
  `50nss = clk-to-q + 4 adders + setup time`

q1_3: |
  3. What is the maximum clock frequency at which the circuit will function correctly? Please include proper units in your answer.

q1_3_s: |
  `20 MHz = 1/50 ns`

q1_4: |
  4. What is the maximum hold time the output registers could have at which the circuit would still function correctly?

q1_4_s: |
  `15 ns`
  <hr class="s1" />
  The result for `s0` arrives in `15ns`, so if it was greater, the hold time would be violated by the second set of inputs

q2_1: |
  # Q2: Datapathology (20 points)
  We want to implement a single-cycle MIPS CPU like the ones addressed in the course that can successfully execute the following instruction:

  ```
  bneqpc $rt $rs IMM
  


  RTL-esque description
  if (R[$rs] != R[$rt]) {
      R[$rt] <- Mem[PC];
      PC <- R[$rs] + (Imm << 2); #HERE
  } else {
      PC <- PC + 4
  }
  ```

  1. Give an example of an R[$rs] and IMM that could potentially cause an error and explain why in two sentences or fewer.

q2_1_s: |
  R[$rs] may not be a word-aligned address

q2_2: |
  Let's assume that the programmer/compiler always made sure that this was not an issue and in the instance where this occurred a trap was raised to debug the issue; do not worry about the potential issue.
  <hr class="s2" />
  For Q2.2, you will be modifying the CPU in order to implement bneqpc. You must also finish filling out the control signal table in Q2.3.
  <hr class="s2" />
  Important observations:
  - Assume that the current state of the CPU does not account for an implementation of bneqpc at all.
  - You are given that the ALU generates a signal "NEQ" that is high when two inputted arguments are not equal and low otherwise.
  - Use the signal "**bneqpc**" as a control signal that is high when the passed-in instruction is bneqpc.

  <hr class="s2" />
  Make sure that the abilities of the original MIPS CPU are still preserved. Hint: Look through all answers before attempting to solve the question. Also, take a look at the given control signals in Q2.3 when working through Q2.2.
  <hr class="s2" />
  After the answer sheet is an incomplete datapath diagram that you can detach. Your job is to find the
  <hr class="s2" />
  2. Your choices for the datapath boxes I-V are shown below. Select the best option that will allow you to implement bneqpc. If you find multiple valid solution combinations, choose the one that uses the **fewest number of extra hardware units overall.**
  <hr class="s2" />
  I. If none of the answers below are sufficient, feel free to draw your answer in D.
  <hr class="s2" />
  ![diagrams](/img/cs61c/mt2-fa15-q2-1.png)

q2_2_s: |
  ![diagrams](/img/cs61c/mt2-fa15-q2-7.png)

q2_3: |
  II. If none of the answers below are sufficient, feel free to draw your answer in D.
  <hr class="s2" />
  ![diagrams](/img/cs61c/mt2-fa15-q2-2.png)

q2_3_s: |
  ![diagrams](/img/cs61c/mt2-fa15-q2-8.png)

q2_4: |
  III. One of the answers is below.
  ![diagrams](/img/cs61c/mt2-fa15-q2-3.png)

q2_4_s: |
  ![diagrams](/img/cs61c/mt2-fa15-q2-9.png)

q2_5: |
  IV. One of the answers is below.
  ![diagrams](/img/cs61c/mt2-fa15-q2-4.png)

q2_5_s: |
  ![diagrams](/img/cs61c/mt2-fa15-q2-10.png)

q2_6: |
  V. If none of the answers below are sufficient, feel free to draw your answer in D.
  ![diagrams](/img/cs61c/mt2-fa15-q2-5.png)

q2_6_s: |
  ![diagrams](/img/cs61c/mt2-fa15-q2-11.png)

q2_7: |
  3. Fill in the control signals in the answer document, some are provided for you. 0 = low, 1 = high, XXX = doesn't matter.
  ![diagrams](/img/cs61c/mt2-fa15-q2-6.png)

q2_7_s: |
  ![diagrams](/img/cs61c/mt2-fa15-q2-12.png)

q3_1: |
  # Q3: Hazardous Conditions (20 points)
  Assume that we have a standard 5-stage pipelined CPU with **no forwarding**. Register file writes can happen before reads, in the **same clock cycle**. We also have comparator logic that begins at the beginning of the decode stage and **calculates the next PC by the end of the decode stage**. For now, assume there is **no branch delay slot**. The remainder of the questions pertains to the following piece of MIPS code:
  ![table](/img/cs61c/mt2-fa15-q3-1.png)
  1. For each instruction dependency below (the line numbers are given), list the type of hazard and the length of the stall needed to resolve the hazard. If there is no hazard, circle “no hazard”.
  <hr class="s1" />
  `0 → 1: addu $t0 $t1 $t4 → addiu $t2 $t0`
  <hr class="s1" />
  `0 → 3: addu $t0 $t1 $t4 → beq $t2 $t3 label`
  <hr class="s1" />
  `1 → 3: addiu $t2 $t0 0 → beq $t2 $t3 label`
  <hr class="s1" />
  `2 → 3: ori $t3 $t2 0xDEAD → beq $t2 $t3 label`
  <hr class="s1" />
  `3 → 4: beq $t2 $t3 label → addiu $t2 $t3 6`

q3_1_s: |
  0 → 1: data hazard, 2 cycles
  <hr class="s1" />
  0 → 3: no hazard
  <hr class="s1" />
  1 → 3: data hazard, 1 cycle
  <hr class="s1" />
  2 → 3: data hazard, 2 cycles
  <hr class="s1" />
  3 → 4: control hazard, 1 cycle

q3_2: |
  For the following questions, assume that our CPU now has forwarding implemented as presented in class and in the book.
  <hr class="s2" />
  2. Which of these instruction dependencies would cause a pipelining hazard?
  <hr class="s1" />
  A. `ori $t3 $t2 0xDEAD → beq $t2 $t3 label`
  <hr class="s1" />
  B. `ori $t3 $t2 0xDEAD → addiu $t2 $t3 6`
  <hr class="s1" />
  C. `ori $t3 $t2 0xDEAD → addiu $v0 $0 10`
  <hr class="s1" />
  D. `beq $t2 $t3 label → addiu $t2 $t3 6`
  <hr class="s1" />
  E. `None of the above`

q3_2_s: |
  A, D

q3_3: |
  3. If we were given a **branch delay slot**, which instruction would reduce the most amount of pipelining hazards if moved into the branch delay slot? If all instructions are equally beneficial, or no instruction removes any hazards, write “nop” as your answer.

q3_3_s: |
  `addiu $v0 $0 10`

q4_1: |
  # Q4: Cache Rules Everything Around Me (15 points)
  You are given a MIPS machine with a single level of **2KiB direct-mapped** cache with **512B cache blocks**. It has **1MiB of physical address space**.
  <hr class="s2" />
  The function foo is ran on the system with a **cold** cache and as the only process:

  ```
  #define ARRAY_LEN 4096
  #define STEP_SIZE 64
  // A starts at 0x10000
  // B starts at 0x20000
  foo( int* A, int* B ) {
      int total = 0;
      for ( int i = 0; i < ARRAY_LEN; i += STEP_SIZE ) {
          total += A[ i ];
          total -= B[ i ];
      }
  }
  ```

  1. Calculate the number of Tag, Index, and Offset bits for this cache.

q4_1_s: |
  Tag: 9
  <hr class="s1" />
  Index: 2
  <hr class="s1" />
  Offset: 9

q4_2: |
  2. Calculate the hit percentage for this cache after running foo.

q4_2_s: |
  0%

q4_3: |
  3. The cache is now cleared and the code is run again. This time, **`A`** and **`B`** are pointing to the same array, which starts at **`0x10000`**. Calculate the new hit percentage.

q4_3_s: |
  75%

q4_4: |
  4. Assume **`A`** and **`B`** starts once again at **`0x10000`** and **`0x20000`**. What is the new hit percentage if we ran foo on a fully associative cache, with all other parameters staying the same?

q4_4_s: |
  50%

q5_1: |
  # Q5: Don’t Let Your Mind Float Away Now (10 points)
  Consider the following 16-bit representation for floating point numbers:
  ![bits](/img/cs61c/mt2-fa15-q5-1.png);
  Bits per field:
  - Sign: 1
  - Exponent: 6
  - Significand: 9
  - Everything else follows the IEEE standard 754 for floating point, except in 16 bits

  <hr class="s2" />
  Bias: -31
  <hr class="s2" />
  1. Convert `-15.125` into floating point. Write your answer in hexadecimal.

q5_1_s: |
  `0xB5B8`

q5_2: |
  2. What is the value of the largest odd number that can be represented by the above floating point representation?

q5_2_s: |
  `2^10 – 1`

q5_3: |
  3. How many positive, real numbers can be represented?

q5_3_s: |
  `2^15 – 2^9 - 1`