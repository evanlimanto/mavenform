course: 'cs61c'
ref: 'mt2-sp15'

type: 'mt2'
term: 'sp15'
prof: 'Stojanovic, Weaver'

questions: {
  'q1': 'SDS',
  'q2': 'Single-cycle Datapath and Control Logic',
  'q3': 'Pipeline Hazards',
  'q4': 'Cache Operations',
  'q5': 'AMAT',
  'q6': 'Floating Point'
}

parts: {
  'q1': 3,
  'q2': 5,
  'q3': 3,
  'q4': 3,
  'q5': 2,
  'q6': 3,
}

q1_1: |
  # Q1: SDS (8 points)
  You are given the following digital circuit. The registers have a setup time of 5ns, a hold time of 3ns, and a CLK-to-Q delay of 5ns, and all logic gates have a delay of 20ns. Assume inputs A and B are driven by registers with the same specifications.
  ![circuit](/img/cs61c/mt2-sp15-q1-1.png)
  a) What is the critical path delay, and what is the maximum clock frequency at which the circuit will operate correctly? You may leave answers as fractions.

q1_1_s: |
  (CLK-to-Q + CL + CL + setup) = 50 ns
  <hr class="s1" />
  1 / (50 ns) = 20 MHz

q1_2: |
  b) Someone meddles with the circuit, increasing the register hold time to 10ns and setting the clock rate to 1 Hz. Will the circuit still work after these changes? Explain your reasoning.

q1_2_s: |
  Hold time violation. CLK-to-Q < hold time so the second register will fail

q1_3: |
  c) What simplification could be made to this circuit to decrease the critical path delay without changing the exact sequence of outputs?

q1_3_s: |
  Replace the left combinational logic with a single XOR gate.
  <hr class="s1" />
  Note that adding a register would change the exact sequence of outputs (delaying by one).

q2_1: |
  # Q2: Single-cycle Datapath and Control Logic (13 points)
  Consider adding the following instruction to MIPS (disregard any existing definitions you may see on the green sheet):
  <hr class="s2" />

  |Instruction|Operation|
  |-----------|---------|
  |`movz rd, rs, rt`|`if (RF[rs] == 0) RF[rd] RF[rt]`|
  |`movnz rd, rs, rt`|`if (RF[rs] != 0) RF[rd] RF[rt]`|

  <hr class="s2" />
  1. Translate the following C code using movz and movnz. Do not use branches.
  <hr class="s2" />

  |C code|MIPS|
  |------|----|
  |// a -> \$s0, b -> \$s1, c -> \$s2<br/>int a = b < c ? b : c;|slt \$t0, \$s1, \$s2|

q2_1_s: |
  |C code|MIPS|
  |------|----|
  |// a -> \$s0, b -> \$s1, c-> \$s2<br/>int a = b < c ? b : c;|slt \$t0, \$s1, \$s2<br/>movnz \$s0, \$t0, \$s1<br/>movz \$s0, \$t0, \$s2|

q2_2: |
  2. Implement <u>**movz**</u> (but not movnz) in the datapath. Choose the correct implementation for (a), (b), and (c). Note that you do not need to use all the signals provided to each box, and the control signal MOVZ is 1 if and only if the instruction is <u>**movz**</u>.
  ![circuit](/img/cs61c/mt2-sp15-q2-1.png)
  (a)![circuit](/img/cs61c/mt2-sp15-q2-2.png)

q2_2_s: |
  3

q2_3: |
  (b)![circuit](/img/cs61c/mt2-sp15-q2-3.png)

q2_3_s: |
  2

q2_4: |
  (c)![circuit](/img/cs61c/mt2-sp15-q2-4.png)

q2_4_s: |
  1

q2_5: |
  3. Generate the control signals for **movz**. The values should be 0, 1, or X (don’t care) terms. You must use don’t care terms where possible.
  ![table](/img/cs61c/mt2-sp15-q2-5.png)
  This table shows the ALUCtr values for each operation of the ALU:
  ![table](/img/cs61c/mt2-sp15-q2-6.png)

q2_5_s: |
  ![table](/img/cs61c/mt2-sp15-q2-7.png)

q3_1: |
  # Q3: Pipeline Hazards (8 points)
  We construct a different five-stage pipelined CPU by swapping the execute and the memory read stages. Note that there is now only indirect addressing for load word and store word.
  ![pipeline](/img/cs61c/mt2-sp15-q3-1.png)
  a. Assume that this pipeline resolves control hazards by pipeline stalls. How many cycles is it stalled on a control hazard?

q3_1_s: |
  3 cycles

q3_2: |
  b. Should the pipeline stall for data hazards from load instructions? Give an example, fill in the corresponding pipeline stages, and explain your idea briefly in one or two sentences.
  (F: Fetch, D: Instruction Decode, M: Memory, E: Execute, W: Write Back, B: Bubble)
  ![table](/img/cs61c/mt2-sp15-q3-2.png)

q3_2_s: |
  ![table](/img/cs61c/mt2-sp15-q3-3.png)
  No, the value of \$t1 are ready before the execute stage of the and instruction. We can forward its value to the next instruction from the pipeline registers without stalling the pipeline.

q3_3: |
  c. Give an example of a data hazard that will stall this pipeline, but not stall the original five-stage pipeline. Be as concise as possible.

q3_3_s: |
  add \$t3, \$t1, \$t2
  <hr class="s1" />
  lw \$t1, 0(\$t3)

q4_1: |
  # Q4: Cache Operations (6 points)
  a) Consider a 32-bit physical memory space and a 32 KiB 2-way associative cache with LRU replacement. You are told the cache uses 5 bits for the offset field. Write in the number of bits in the tag and index fields in the figure below.
  ![table](/img/cs61c/mt2-sp15-q4-1.png)

q4_1_s: |
  ![table](/img/cs61c/mt2-sp15-q4-2.png)

q4_2: |
  b) Assume the same cache as in part a).

  ```
  int ARRAY_SIZE = 64 * 1024;
  int arr[ARRAY_SIZE]; // *arr is aligned to a cache block

  /* loop 1 */ for (int i = 0; i < ARRAY_SIZE; i += 8) arr[i] = i;
  /* loop 2 */ for (int i = ARRAY_SIZE – 8; i >= 0; i -= 8) arr[i+1] = arr[i];
  ```

  1. What is the hit rate of loop 1? What types of misses (of the 3 Cs), if any, occur as a result of loop 1?

q4_2_s: |
  0% hit rate, Compulsory Misses

q4_3: |
  2. What is the hit rate of loop 2? What types of misses (of the 3 Cs), if any, occur as a result of loop 2?

q4_3_s: |
  9/16 hit rate, Capacity Misses

q5_1: |
  # Q5: AMAT (4 points)
  Suppose you have the following system that consists of an:
  <hr class="s1" />
  L1\$ with a local hit rate of 80% and a hit time of 2 cycles
  <hr class="s1" />
  L2\$ with a global miss rate of 8% and a hit time of 15 cycles
  <hr class="s1" />
  DRAM accesses take 50 cycles
  <hr class="s2" />
  i. What is the AMAT of the L1 cache? ________________________________

q5_1_s: |
  2 + 0.2 * (15 + 0.4 * 50) = 9

q5_2: |
  ii. Suppose we want to improve our AMAT, making sure that it is no greater than 6 cycles, by improving our L2\$’s hit rate. What is the minimum possible local hit rate for L2\$ that allows us to meet our AMAT requirement?

q5_2_s: |
  90%

q6_1: |
  # Q6: Floating Point (6 points)
  We want to develop a new half-precision floating-point standard for 16-bit machines. The basic structure is as follows:
  ![bits](/img/cs61c/mt2-sp15-q6-1.png)
  Here are the design choices:
  - 1 bit for sign
  - 7 bits for a signed exponent in 2’s complement
  - 8 bits for the significand
  - Everything else follows the IEEE standard 754 for floating point, except in 16 bits.

  <hr class="s2" />
  In this new standard:
  <hr class="s1" />
  a) Convert the decimal number -10.625 to floating point. Write your answer in hexadecimal.

q6_1_s: |
  -1010.101
  <hr class="s1" />
  sign: 1
  <hr class="s1" />
  exponent: 3 -> 0x03
  <hr class="s1" />
  significand: 01010100 -> 0x54
  <hr class="s2" />
  0x8354

q6_2: |
  b) What is the smallest even number that is not representable?

q6_2_s: |
  2^10+2

q6_3: |
  c) What is the smallest positive denormalized number?

q6_3_s: |
  2^-70 or 0x4001