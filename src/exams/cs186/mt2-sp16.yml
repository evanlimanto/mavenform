course: 'cs186'
ref: 'mt2-sp16'

type: 'mt2'
term: 'sp16'
prof: 'Hellerstein'

questions: {
  'q1': 'Locking and Serializability',
  'q2': 'Query Optimization',
  'q3': 'Recovery',
}

parts: {
  'q1': 18,
  'q2': 6,
  'q3': 7,
}

q1_1: |
  ## I. Locking and Serializability
  1. For the following statements, list the true statement(s) in alphabetical order.
  <hr class="s1" />
  a. Schedules that are conflict serializable are also view serializable.

q1_1_s: |
  True.

q1_2: |
  b. Under two phase locking, once a transaction releases a lock, it can no longer acquire any new locks.

q1_2_s: |
  True.

q1_3: |
  c. Schedules that are conflict serializable have to be produced by two­phase locking.

q1_3_s: |
  False. Note that the converse is true - 2PL guarantees conflict serializability.

q1_4: |
  d. Schedules produced by two­phase locking are guaranteed to prevent cascading aborts.

q1_4_s: |
  False. Strict 2PL is needed to guarantee this.

q1_5: |
  e. Strict two­phase locking is both necessary and sufficient to guarantee conflict serializability.

q1_5_s: |
  False. Sufficient but not necessary.

q1_6: |
  f. Wound-­wait and wait­-die algorithms are pessimistic deadlock avoidance algorithms and can cause more transaction aborts than needed.

q1_6_s: |
  True.

q1_7: |
  g. Under multi­granularity locking, locks should be acquired and released from the top level to the bottom level.

q1_7_s: |
  False. Locks are acquired top down, but released bottom up.

q1_8: |
  h. Under multi­granularity locking, when a transaction T1 is holding an ‘IX’ lock on page A, it is possible for transaction T2 to hold a ‘S’ lock on record B of page A.

q1_8_s: |
  True.
  <hr class="s1" />
  *Instructor note: Some of these might seem like arbitrary rules, but they all exist for a reason. For each, do you understand why?

q1_9: |
  Consider the following schedule consisting purely of reads and writes on the tuple level ({A, B, C} are tuples). The meaings of operations are shown below:
  <hr class="s2" />
  W(A): transaction writes tuple A.
  <hr class="s1" />
  R(A): transaction reads tuple A.
  <hr class="s1" />
  COM: transaction commits.
  <hr class="s2" />
  ![operations](/img/cs186/mt2-sp16-q1-1.png)
  <hr class="s2" />
  2. [4 points] Draw the dependency graph for this schedule.

q1_9_s: |
  ![graph](/img/cs186/mt2-sp16-q1-4.png)

q1_10: |
  3. [4 points] Of the following, list all conflict equivalent serial orderings of this schedule in alphabetical order:
  <hr class="s1" />
  A. T2 T1 T4 T3
  <hr class="s1" />
  B. T2 T3 T4 T1
  <hr class="s1" />
  C. T2 T1 T3 T4
  <hr class="s1" />
  D. T2 T4 T1 T3

q1_10_s: |
  B, C.

q1_11: |
  4. [2 point] List one read that could occur between timestep 9 and 10 that would make this schedule not conflict serializable. For example, if T1 reading A is an answer, write “T1: R(A)”

q1_11_s: |
  There were multilpe answers: T2:R(A) or T2:R(B) or T2:R(C) or T3:R(B).

q1_12: |
  Consider the following schedule. The meanings of operations are the same as in the previous problem. <u>You may assume that locks could have been acquired or released at any time in between timesteps, and the scheduler may know all operations of transactions ahead of time.</u>
  <hr class="s2" />
  ![operations](/img/cs186/mt2-sp16-q1-2.png)
  <hr class="s2" />
  5. [3 points] For the following statements, list the true statement(s) in alphabetical order.
  <hr class="s1" />
  A. It is possible for this schedule to be produced by two-phase locking.
  <hr class="s1" />
  B. It is possible for this schedule to be produced by strict two-phase locking.
  <hr class="s1" />
  C. This schedule is guaranteed not to have cascading aborts.

q1_12_s: |
  A. True.
  <hr class="s1" />
  B. False, Recall that strict 2PL releases locks at commit.
  <hr class="s1" />
  C. True.

q1_13: |
  Suppose that we have a table Y, with pages {A, B, C}, and tuples {$A_1$, $A_2$, $A_3$, ...} in page A, and tuples {$B_1$, $B_2$, $B_3$, ...} in page B, and tuples {$C_1$, $C_2$, $C_3$, ...} in page C. Below is a schedule that correctly follows strict two-phase locking and multi-granularity locking protocols. For clarity, operations that are blocked (because of failing to acquire the lock) are italicized and underlined.
  <hr class="s2" />
  ![locking](/img/cs186/mt2-sp16-q1-3.png)
  <hr class="s2" />
  6. [4 points] What locks have been acquired on table Y at timestep 9? For each lock, list the transaction it belongs to, and its type. Do not list locks that are on the wait queue, and use locks with minimal privilege. For example, if T1 has an S lock, and T2 has an X lock, write “T1:S, T2:X”.

q1_13_s: |
  T1:IX, T2: IX, T3: IX, T4: IX
  <hr class="s1" />
  *All transaction tried to write to the table, so they all have IX locks. Note that transactions that started with IS locks will upgraded those locks to IX. Also note that no transaction has to wait for a lock at the table level, since there are no S or X locks at that level. All waiting happens at lower levels.

q1_14: |
  7. [2 points] What locks have been acquired on page B at timestep 9? For each lock, list the transaction it belongs to, and its type. Do not list locks that are on the wait queue, and use locks with minimal privilege.

q1_14_s: |
  T1: IX, T2: IS
  <hr class="s1" />
  *T1 has an IX lock, as it wrote to B 1.  T2 has an IS lock, as it read from B 2  ­ it does  not  have an X lock, as it is waiting for T1.
  <hr class="s1" />
  Tying this back to the previous question, before T2 writes to B, it will successfully acquire the IX on table Y, but will have to wait for T1 before acquiring the X on B.

q1_15: |
  8. [6 points] There is a deadlock in this schedule (i.e. it is waiting indefinitely for locks).
  <hr class="s1" />
  8.1. Draw the waits-for graph for this schedule.

q1_15_s: |
  ![graph](/img/cs186/mt2-sp16-q1-5.png)

q1_16: |
  8.2. Which transactions are involved in the deadlock?

q1_16_s: |
  These are the transactions in the cycle above: T2 T4

q1_17: |
  8.3. Circle all true statements (on the answer sheet):
    A. We can resolve this deadlock by aborting any transaction involved in the deadlock.
    <hr class="s1" />
    B. No transaction can proceed until this deadlock is resolved.

q1_17_s: |
  A. True.
  <hr class="s1" />
  B. False. In this schedule, T3 can clearly proceed.

q1_18: |
  9. [2 points] Suppose T1 wishes to scan page B between timestep 8 and 9. Which locks are upgraded at this time? For example, if an S lock on A1 is upgraded to an X lock, write “S(A1) → X(A1)”. If there are no upgrades, or if all upgrades are placed on the wait queue, write “None”.

q1_18_s: |
  IX(B) ­> SIX(B)
  <hr class="s1" />
   *At this time, T1 has IX(Y), IX(B), and X($B_1$). So, T1 only needs to *upgrade* its lock on B. Recall that we are working with Strict 2PL, so it cannot drop the IX on B.

q2_1: |
  ## II. Query Optimization [26 points]
  1. [6 points] Write down letters for all the correct statements (in alphabetical order)
  <hr class="s1" />
  A. When evaluating potential query plans, the set of left deep join plans are always guaranteed to contain the best plan.
  <hr class="s1" />
  B. As a heuristic, the System R optimizer avoids cross-products if possible.
  <hr class="s1" />
  C. Considering all join orders and join methods, there are n! ways to join n tables.
  <hr class="s1" />
  D. A plan can result in an interesting order if it involves a sort-merge join.
  <hr class="s1" />
  E. The System R algorithm is greedy because for each pass, it only keeps the lowest cost plan for each combination of tables.
  <hr class="s1" />
  F. If the statistics needed to compute the result size of a table are missing, the System R optimizer aborts.

q2_1_s: |
  a. False - this is a heuristic that System R uses to shrink the search space.
  <hr class="s1" />
  b. True.
  <hr class="s1" />
  c. False. During the exam we amended this question to say O(n!) ­­ it is still false, but ends up being a bit harder to prove, so we gave everyone a point for this question.
  <hr class="s1" />
  d. True.
  <hr class="s1" />
  e. False ­ it is not greedy because it keeps track of interesting orders.
  <hr class="s1" />
  f. False ­ it uses 1/10 as reduction factor if it cannot be computed.

q2_2: |
  For the following question, assume the following:
  - the System R assumptions about uniformity and independence from lecture hold
  - **primary key IDs are sequential, starting from 1**
  - all of our tables are stored as heap files
  <hr class="s2" />
  We have the following schema:
  <hr class="s2" />
  ![schema](/img/cs186/mt2-sp16-q2-1.png)
  <hr class="s2" />
  2. Consider the following query:
  ```
  SELECT *
  FROM Flight F, City C, Airline A
  WHERE F.to_cid = C.cid AND F.aid = A.aid
  AND F.aid >= 2500
  AND C.population > 5e6
  AND C.state = 'California';
  ```
  2.1 [4 points] Considering each predicate in the WHERE clause separately, what is the reduction factor for each?
  <hr class="s2" />
  i. R1 = C.state='California'       _____/______
  <hr class="s1" />
  ii. R2 = F.to_cid = C.cid          _____/______
  <hr class="s1" />
  iii. R3 = F.aid >= 2500            _____/______
  <hr class="s1" />
  iv. R4 = C.population > 5 * 10^6   _____/______

q2_2_s: |
  i. 1/50
  <hr class="s1" />
  ii. 1/50000
  <hr class="s1" />
  iii. 2501/5000
  <hr class="s1" />
  iv. (3*10^6) / (7*10^6 + 1)

q2_3: |
  2.2. [5 points] For each blank in the our System R DP table for Pass 1, choose the letter corresponding to the correct solution (Assume this is before the optimizer discards any rows it isn’t interested in keeping).
  <hr class="s2" />
  ![table](/img/cs186/mt2-sp16-q2-2.png)

q2_3_s: |
  i. B
  <hr class="s1" />
  ii. $\emptyset$. The correct answer is 1000020*R3
  <hr class="s1" />
  iii. A
  <hr class="s1" />
  iv. D
  <hr class="s1" />
  v. C

q2_4: |
  2.3. [3 points] For simplicity, let’s assume each individual reduction factor (Ri) is 1/2. Then, what is the **READ** I/O cost of (City [Index (III)] JOIN Flights [File Scan]), using Page Nested Loops Join?

q2_4_s: |
  [[NPages(Index III) + NPages(C)]*1⁄2 + 1⁄2 1⁄2 NPages(C) * NPages(F)
  <hr class="s1" />
  15 + 5*50 = 265 I/Os
  <hr class="s2" />
  We will access City using Index (III) which gives an outer cost of [NPages(Index III) + NPages(C)]*1⁄2. We can only apply one reduction factor because Index III is only on population.
  <hr class="s2" />
  How many pages worth of tuples will be candidates to be joined with F? 1⁄2 1⁄2 NPages(C) because of the two predicates.
  <hr class="s2" />
  To access F, we have to use a page scan: NPages(F).
  <hr class="s2" />
  Common mistakes were to forget the index access cost for the outer loop, applying the wrong reduction factors, or having F as the outside releation. “A JOIN B” is typically interpreted to have A on the outside, and furthermore we always put the smaller relation on the outside to minimize I/O cost.

q2_5: |
  2.4. [3 points] After Pass 2, which of the following plans could be in the DP table? 
  A. City[Index(III)] JOIN Airline[Filescan]
  <hr class="s1" />
  B. City[Index(III)] JOIN Flight[Index(I)]
  <hr class="s1" />
  C. Flight[Index(II)] JOIN City[Index(III)]

q2_5_s: |
  A. False, this is a cross product.
  <hr class="s1" />
  B. True, this could possibly be in the table.
  <hr class="s1" />
  C. False, Index (II) would not have been kept as a Single Table Access Method.

q2_6: |
  2.5.[5 points] Suppose we want to optimize for queries similar to the query in #2, which of the following suggestions could reduce I/O cost?
  A. Maintain a more detailed histogram of Cities.population
  B. Change Index (III) to be unclustered
  C. Reduce the size of Airline.name field using string compression
  D. Add a hash index on Flights.aid
  E. Store City as a sorted file on population

q2_6_s: |
  A. We gave everyone points for A since it was vague. Maintaining the histograms helps, but only if we also update our optimizer to use these more advanced statistics for its cost estimation (which the answer choice did not explain).
  <hr class="s1" />
  B. An unclustered index would not minimize I/O cost, since it’s more random I/O, and we may load a page more than once.
  <hr class="s1" />
  C. Fitting more records per page means fewer I/Os.
  <hr class="s1" />
  D. Hash index allows us to do a different kind of index nested loops join, which may reduce I/O cost.
  <hr class="s1" />
  E. Sorted file may provide more efficient range lookups.

q3_1: |
  ## III. Recovery [24 points]
  1. [6 points] List all the true statements in alphabetical order:
  <hr class="s1" />
  A. When a transaction commits, any modified buffer pages must be written to durable storage.
  <hr class="s1" />
  B. When aborting a transaction, it may be necessary to modify pages on disk.
  <hr class="s1" />
  C. During recovery, the ARIES protocol may redo aborted transactions.
  <hr class="s1" />
  D. The pageLSN contains the LSN of the last operation to modify the page.
  <hr class="s1" />
  E. The tail of the log is always flushed after every update operation.
  <hr class="s1" />
  F. A system that uses a FORCE, STEAL policy does not need to undo any operations after
  a crash.

q3_1_s: |
  a. False. ARIES uses a NO FORCE policy.
  <hr class="s1" />
  b. True. ARIES uses a STEAL policy.
  <hr class="s1" />
  c. True. This is a key feature of ARIES and essential for the correctness of the protocol.
  <hr class="s1" />
  d. True. This is the definition of the pageLSN.
  <hr class="s1" />
  e. False. We only require that the tail of the log be flushed on commit. Remember that flushedLSN keeps track of the log tail.
  <hr class="s1" />
  f. False. A system with a STEAL policy needs UNDO logging to ensure atomicity.

q3_2: |
  Questions 2 through 7 use the log below. Our database system is using ARIES for recovery. Some of the information for update and CLR log records is omitted for brevity. Adjacent log records are spaced exactly 10 LSN's apart. The system crashes after the last log record is written.
  <hr class="s2" />
  ![aries](/img/cs186/mt2-sp16-q3-1.png)
  <hr class="s2" />
  Transaction Table and Dirty Page Table recorded at end_checkpoint (LSN 70).
  <hr class="s2" />
  ![transaction table and dirty page table](/img/cs186/mt2-sp16-q3-2.png)
  <hr class="s2" />
  2. [1 point] The page updated by LSN 0 has been written to disk when the system starts recovering from the crash.
  <hr class="s1" />
  A. True
  <hr class="s1" />
  B. False
  <hr class="s1" />
  C. Not enough information

q3_2_s: |
  a. At the time of the begin_checkpoint record, P1 appears in the dirty page table with recLSN 20, so the update at LSN 0 has definitely been materialized on disk.

q3_3: |
  3. [1 point] The page updated by LSN 60 has been written to disk when the system starts recovering from the crash.
  <hr class="s1" />
  A. True
  <hr class="s1" />
  B. False
  <hr class="s1" />
  C. Not enough information

q3_3_s: |
  c. When T2 committed, all log records for T2 were forced to the stable log. However, because we are using a NO FORCE policy, the data pages themselves may not have been forced to disk.

q3_4: |
  4. [1 point] What is the undoNextLSN of the CLR at LSN 120?

q3_4_s: |
  0. The undoNextLSN of a CLR indicates the LSN of the next CLR that will be written for that transaction, or null if all CLR’s for that transaction have been written.

q3_5: |
  5. [6 points] Fill in the transaction table and dirty page table after Analysis. Do not add any transactions to the transaction table (it should only contain T1 and T3). You may not need to use all rows provided in the dirty page table.
  <hr class="s2" />
  <table>
  <thead><tr><th colspan="3">Transaction Table</th><th colspan="2">Dirty Page Table</th></tr><tr><th>Transaction</th><th>lastLSN</th><th>Status</th><th>PageID</th><th>recLSN</th></tr></thead>
  <tbody>
  <tr><td></td><td></td><td></td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td></tr>
  </tbody>
  </table>

q3_5_s: |
  ![table](/img/cs186/mt2-sp16-q3-3.png)

q3_6: |
  6. [3 points] List the LSN’s of the actions that are redone during REDO. Assume that nothing in the buffer pool was flushed to disk between begin checkpoint and the time of crash.

q3_6_s: |
  20, 30, 50, 60, 90, 120

q3_7: |
  7. [6 points] What log records are written during UNDO? Fill in the remaining columns for the records below. You may not need to use all rows in the table.
  <hr class="s1" />
  Hint: T1 and T3 are the only "loser" transactions.
  <hr class="s2" />
  <table>
    <thead><tr><th>LSN</th><th>Record</th><th>prevLSN</th></tr></thead>
    <tbody>
      <tr><td>200</td><td></td><td></td></tr>
      <tr><td>210</td><td></td><td></td></tr>
      <tr><td>220</td><td></td><td></td></tr>
      <tr><td>230</td><td></td><td></td></tr>
      <tr><td>240</td><td></td><td></td></tr>
      <tr><td>250</td><td></td><td></td></tr>
      <tr><td>260</td><td></td><td></td></tr>
    </tbody>
  </table>

q3_7_s: |
  ![table](/img/cs186/mt2-sp16-q3-4.png)
