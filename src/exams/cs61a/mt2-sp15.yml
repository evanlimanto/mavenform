course: 'cs61a'
ref: 'mt2-sp15'

type: 'mt2'
term: 'sp15'
prof: 'DeNero'

questions: {
  'q1': 'Mutater-tot',
  'q2': 'Vulcans',
  'q3': 'Will Code for Points',
  'q4': 'What color is it?',
}

parts: {
  'q1': 1,
  'q2': 2,
  'q3': 4,
  'q4': 2,
}

q1_1: |
  ## 1. (12 points) Mutater-tot
  For each of the expressions in the table below, write the output displayed by the interactive Python interpreter when the expression is evaluated. **The output may have multiple lines.** Expressions are evaluated in order, and **expressions may affect later expressions.**
  <hr class="s1" />
  Whenever the interpreter would report an error, write Error. If execution would take forever, write Forever.
  <hr class="s1" />
  Assume that you have started Python 3 and executed the following statements:
  ```
  def ready(betty):
      print(len(betty))
      betty[0].append(betty)
      return betty[0:1]

  def get_set(s):
      ready(s)
      return s.pop()

  def go(on, up):
      if up:
          return go(on[0], up-1)
      else:
          return on

  f = [1, [2]]
  g = [[3, 4], [5], 6]
  h = [g, g]
  ```

  |Expression|Interactive Output|
  |----------|------------------|
  |`f.pop()`|`[2]`|
  |`h[1].pop()`||
  |`g[g[1][0] - g[0][1]]`||
  |`len(ready(g))`||
  |`g[0][2][0][1]`||
  |`ready(get_set(h))[0][0]`||
  |`[len(go(h, k)) for k in range(3)]`|||

q1_1_s: |
  |Expression|Interactive Output|
  |----------|------------------|
  |`f.pop()`|`[2]`|
  |`h[1].pop()`|`6`|
  |`g[g[1][0] - g[0][1]]`|`[5]`|
  |`len(ready(g))`|`2`<br/>`1`|
  |`g[0][2][0][1]`|`4`|
  |`ready(get_set(h))[0][0]`|`2`<br/>`3`<br/>`3`|
  |`[len(go(h, k)) for k in range(3)]`|`[1, 3, 4]`|

q2_1: |
  ## 2. (12 points) Vulcans
  **(a) (8 pt)** Fill in the environment diagram that results from executing the code below until the entire program is finished, an error occurs, or all frames are filled. *You may not need to use all of the spaces or frames*.
  <hr class="s2" />
  A complete answer will:
  <hr class="s1" />
  - Add all missing names and parent annotations to all local frames.
  - Add all missing values created or referenced during execution.
  - Show the return value for each local frame.

  <hr class="s2" />
  **Remember:** Do not add a new frame when calling a built-in function (such as `abs`). The built-in abs function is always written as `func abs(...) [parent=Global]`.
  <hr class="s2" />
  ![environment diagram](/img/cs61a/mt2-sp15-q2-1.png)

q2_1_s: |
  ![environment diagram](/img/cs61a/mt2-sp15-q2-2.png)

q2_2: |
  **(b) (4 pt)** Fill in the environment diagram that results from executing the code below after the entire program is finished. No errors occur during the execution of this example.
  <hr class="s1" />
  A complete answer will:
  <hr class="s1" />
  - Add all missing values created or referenced during execution.
  - Show the return value for each local frame.
  <hr class="s2" />
  ![environment diagram](/img/cs61a/mt2-sp15-q2-3.png)

q2_2_s: |
  ![environment diagram](/img/cs61a/mt2-sp15-q2-4.png)

q3_1: |
  ## 3. (14 points) Will Code for Points
  **(a) (2 pt)** Implement `objectify`, which takes a tree data abstraction and returns an equivalent `Tree` instance. Both the `Tree` class and the tree data abstraction appear on the midterm 2 study guide.
  <hr class="s1" />
  *Warning: Do not violate the tree data abstraction! (Exams are flammable.)*

  ```
  def objectify(t):
      """Return a Tree instance equivalent to a tree represented as a list.

      >>> m = tree(2)
      >>> m
      [2]
      >>> objectify(m)
      Tree(2)
      >>> r = tree(3, [tree(4, [tree(5), tree(6)]), tree(7, [tree(8)])])
      >>> r
      [3, [4, [5], [6]], [7, [8]]]
      >>> objectify(r)
      Tree(3, [Tree(4, [Tree(5), Tree(6)]), Tree(7, [Tree(8)])])
      """
      return ___________________________________________________________________
  ```

q3_1_s: |
  ```
  def objectify(t):
      """Return a Tree instance equivalent to a tree represented as a list.

      >>> m = tree(2)
      >>> m
      [2]
      >>> objectify(m)
      Tree(2)
      >>> r = tree(3, [tree(4, [tree(5), tree(6)]), tree(7, [tree(8)])])
      >>> r
      [3, [4, [5], [6]], [7, [8]]]
      >>> objectify(r)
      Tree(3, [Tree(4, [Tree(5), Tree(6)]), Tree(7, [Tree(8)])])
      """
      return <b>Tree(root(t), [objectify(b) for b in branches(t)])</b>
  ```

q3_2: |
  **(b) (2 pt)** Circle the `Θ` expression that describes the number of `Tree` instances constructed by calling `objectify` on a tree with `n` nodes.
  <hr class="s2" />
  `Θ(1)        Θ(log n)        Θ(n)        Θ(n^2)        Θ(2^n)`

q3_2_s: |
  `Θ(n)`

q3_3: |
  **(c) (4 pt)** Implement closest, which takes a `Tree` of numbers t and returns the smallest absolute difference anywhere in the tree between an entry and the sum of the entries of its branches. The `Tree` class appears on the midterm 2 study guide. The built-in `min` function takes a sequence and returns its minimum value.
  <hr class="s1" />
  *Reminder*: A branch of a branch of a tree `t` is *not* considered to be a branch of `t`.

  ```
  def closest(t):
      """Return the smallest difference between an entry and the sum of the entries of its branches.
      >>> t = Tree(8, [Tree(4), Tree(3)])
      >>> closest(t) # |8 - (4 + 3)| = 1
      1
      >>> closest(Tree(5, [t])) # Same minimum as t
      1
      >>> closest(Tree(10, [Tree(2), t])) # |10 - (2 + 8)| = 0
      0
      >>> closest(Tree(3)) # |3 - 0| = 3
      3
      >>> closest(Tree(8, [Tree(3, [Tree(1, [Tree(5)])])])) # |3 - 1| = 2
      2
      >>> sum ([])
      0
      """
      diff = abs(_______________________________________________________________)

      return min(_______________________________________________________________)
  ```

q3_3_s: |
  ```
  def closest(t):
      """Return the smallest difference between an entry and the sum of the entries of its branches.
      >>> t = Tree(8, [Tree(4), Tree(3)])
      >>> closest(t) # |8 - (4 + 3)| = 1
      1
      >>> closest(Tree(5, [t])) # Same minimum as t
      1
      >>> closest(Tree(10, [Tree(2), t])) # |10 - (2 + 8)| = 0
      0
      >>> closest(Tree(3)) # |3 - 0| = 3
      3
      >>> closest(Tree(8, [Tree(3, [Tree(1, [Tree(5)])])])) # |3 - 1| = 2
      2
      >>> sum ([])
      0
      """
      diff = abs(<b>t.entry - sum([b.entry for b in t.branches])</b>)

      return min(<b>[diff] + [closest(b) for b in t.branches]</b>)
  ```

q3_4: |
  **(d) (6 pt)** Implement `double_up`, which mutates a linked list by inserting elements so that each element is adjacent to an equal element. The `double_up` function inserts as few elements as possible and returns the number of insertions. The `Link` class appears on the midterm 2 study guide.
  ```
  def double_up(s):
      """Mutate s by inserting elements so that each element is next to an equal.
      >>> s = Link(3, Link(4))
      >>> double_up(s) # Inserts 3 and 4
      2
      >>> s
      Link(3, Link(3, Link(4, Link(4))))
      >>> t = Link(3, Link(4, Link(4, Link(5))))
      >>> double_up(t) # Inserts 3 and 5
      2
      >>> t
      Link(3, Link(3, Link(4, Link(4, Link(5, Link(5))))))
      >>> u = Link(3, Link(4, Link(3)))
      >>> double_up(u) # Inserts 3, 4, and 3
      3
      >>> u
      Link(3, Link(3, Link(4, Link(4, Link(3, Link(3))))))
      """
      if s is Link.empty:

          return 0

      elif s.rest is Link.empty:

          _____________ = ___________________________________________________

          return ____________________________________________________________

      elif __________________________________________________________________:

          return double_up(__________________________________________________)

      else:
          _____________ = ___________________________________________________

          return ____________________________________________________________
  ```

q3_4_s: |
  ```
  def double_up(s):
      """Mutate s by inserting elements so that each element is next to an equal.
      >>> s = Link(3, Link(4))
      >>> double_up(s) # Inserts 3 and 4
      2
      >>> s
      Link(3, Link(3, Link(4, Link(4))))
      >>> t = Link(3, Link(4, Link(4, Link(5))))
      >>> double_up(t) # Inserts 3 and 5
      2
      >>> t
      Link(3, Link(3, Link(4, Link(4, Link(5, Link(5))))))
      >>> u = Link(3, Link(4, Link(3)))
      >>> double_up(u) # Inserts 3, 4, and 3
      3
      >>> u
      Link(3, Link(3, Link(4, Link(4, Link(3, Link(3))))))
      """
      if s is Link.empty:

          return 0

      elif s.rest is Link.empty:

          <b>s.rest</b> = <b>Link(s.first)</b>

          return <b>1</b>

      elif <b>s.first == s.rest.first</b>:

          return double_up(<b>s.rest.rest</b>)

      else:

          <b>s.rest</b> = <b>Link(s.first, s.rest)</b>

          return <b>1 + double_up(s.rest.rest)</b>
  ```

q4_1: |
  ## 4. (12 points) What color is it?
  **(a) (6 pt)** Implement the `look` method of the `Dress` class. The `look` method returns a `Dress` instance’s current `color` when the number of times that the instance’s `look` method has ever been invoked evenly divides the total number times that the `look` method of any `Dress` instance has ever been invoked. Otherwise, the instance’s `color` changes to the most recently returned color from any call to `look`, and `None` is returned.
  ```
  class Dress:
      """What color is the dress?

      >>> blue = Dress(’blue’)
      >>> blue.look()
      ’blue’
      >>> gold = Dress(’gold’)
      >>> gold.look()
      ’gold’
      >>> blue.look() # 2 does not evenly divide 3; changes to gold
      >>> Dress(’black’).look()
      ’black’
      >>> gold.look() # 2 does not evenly divide 5; changes to black
      >>> gold.look() # 3 evenly divides 6
      ’black’
      >>> Dress(’white’).look()
      ’white’
      >>> gold.look() # 4 evenly divides 8
      ’black’
      >>> blue.look() # 3 evenly divides 9
      ’gold’
      """
      seen = 0
      color = None

      def __init__(self, color):
          self.color = color
          self.seen = 0

      def look(self):

          _______________________ = ____________________________________________

          _______________________ = ____________________________________________

          if ___________________________________________________________________:

              _____________________________ = __________________________________

              return ___________________________________________________________

          else:

              _____________________________ = __________________________________
  ```

q4_1_s: |
  ```
  class Dress:
      """What color is the dress?

      >>> blue = Dress(’blue’)
      >>> blue.look()
      ’blue’
      >>> gold = Dress(’gold’)
      >>> gold.look()
      ’gold’
      >>> blue.look() # 2 does not evenly divide 3; changes to gold
      >>> Dress(’black’).look()
      ’black’
      >>> gold.look() # 2 does not evenly divide 5; changes to black
      >>> gold.look() # 3 evenly divides 6
      ’black’
      >>> Dress(’white’).look()
      ’white’
      >>> gold.look() # 4 evenly divides 8
      ’black’
      >>> blue.look() # 3 evenly divides 9
      ’gold’
      """
      seen = 0
      color = None

      def __init__(self, color):
          self.color = color
          self.seen = 0

      def look(self):

          <b>Dress.seen += 1</b>

          <b>self.seen += 1</b>

          if <b>Dress.seen % self.seen == 0</b>:

              <b>Dress.color</b> = <b>self.color</b>

              return <b>self.color</b>

          else:

              <b>self.color</b> = <b>Dress.color</b>
  ```

q4_2: |
  **(b) (6 pt)** Implement `decrypt`, which takes a string `s` and a dictionary `d` that contains words as values and their secret codes as keys. It returns a list of all possible ways in which `s` can be decoded by splitting it into secret codes and separating the corresponding words by spaces.

  ```
  def decrypt(s, d):
      """List all possible decoded strings of s.
      >>> codes = {
      ...    ’alan’: ’spooky’,
      ...    ’al’: ’drink’,
      ...    ’antu’: ’your’,
      ...    ’turing’: ’ghosts’,
      ...    ’tur’: ’scary’,
      ...    ’ing’: ’skeletons’,
      ...    ’ring’: ’ovaltine’
      ... }
      >>> decrypt(’alanturing’, codes)
      [’drink your ovaltine’, ’spooky ghosts’, ’spooky scary skeletons’]
      """

      if s == ’’:

          return []

      messages = []

      if ______________________________________________________________________:

          messages.append(___________________________________________________________)

      for k in ________________________________________________________________:

          first , suffix = s[:k], s[k:]

          if __________________________________________________________________:

              for rest in _____________________________________________________:

                  messages.append(___________________________________________________)

      return messages
  ```

q4_2_s: |
  ```
  def decrypt(s, d):
      """List all possible decoded strings of s.
      >>> codes = {
      ...    ’alan’: ’spooky’,
      ...    ’al’: ’drink’,
      ...    ’antu’: ’your’,
      ...    ’turing’: ’ghosts’,
      ...    ’tur’: ’scary’,
      ...    ’ing’: ’skeletons’,
      ...    ’ring’: ’ovaltine’
      ... }
      >>> decrypt(’alanturing’, codes)
      [’drink your ovaltine’, ’spooky ghosts’, ’spooky scary skeletons’]
      """

      if s == ’’:

          return []

      messages = []

      if <b>s in d</b>:

          messages.append(d[s])

      for k in <b>range(1, len(s)+1)</b>:

          first , suffix = s[:k], s[k:]

          if <b>first in d</b>:

              for rest in <b>decrypt(suffix , d)</b>:

                  messages.append(<b>d[first] + ’ ’ + rest</b>)

      return messages
  ```
