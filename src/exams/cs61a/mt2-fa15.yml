course: 'cs61a'
ref: 'mt2-fa15'

type: 'mt2'
term: 'fa15'
prof: 'DeNero'

questions: {
  'q1': 'ok --submit',
  'q2': 'Exercises',
  'q3': 'Return of the Digits',
}

parts: {
  'q1': 1,
  'q2': 2,
  'q3': 5,
}

q1_1: |
  ## 1. (12 points) ok --submit
  For each of the expressions in the table below, write the output displayed by the interactive Python interpreter when the expression is evaluated. The output may have multiple lines. If more than 3 lines are displayed, just write the first 3. If an error occurs, write “Error”. If evaluation would run forever, write “Forever”.
  <hr class="s1" />
  The first two rows have been provided as examples.
  <hr class="s1" />
  Assume that you have started `python3` and executed the following statements (which do not cause errors):

  ```
  class Ok:
      py = [3.14]
      def __init__(self, py):
          self.ok = self.py
          Ok.py.append(3 * py)
      def my(self, eye):
          print(self.my(eye))
          return self.ok.pop()
      def __str__(self):
          return str(self.ok)[:4]

  class Go(Ok):
      def my(self, help):
          return [help+3, len(Ok.py)]

  oh = Go (5)
  Go.py = [3, 1, 4]
  oh.no = {’just’: Go(9)}
  ```

  |Expression|Interactive Output|
  |----------|------------------|
  |`'z' * 3`|'zzz'|
  |`print(4, 5) + 1`|`4 5`<br/>`Error`|
  |`oh.py`||
  |`oh.my(3)`||
  |`oh.ok + oh.no['just'].ok`||
  |`print(oh)`||
  |`Ok('go').my(5)`||
  |`Ok.my(oh, 5)`|||

q1_1_s: |
  |Expression|Interactive Output|
  |----------|------------------|
  |`'z' * 3`|'zzz'|
  |`print(4, 5) + 1`|`4 5`<br/>`Error`|
  |`oh.py`|`[3, 1, 4]`|
  |`oh.my(3)`|`[6, 3]`|
  |`oh.ok + oh.no['just'].ok`|`[3.14, 15, 27, 3, 1, 4]`|
  |`print(oh)`|`[3.1`|
  |`Ok('go').my(5)`|"Error"|
  |`Ok.my(oh, 5)`|`[8, 4]`<br/>`'gogogo'`|

q2_1: |
  ## 2. (14 points) Exercises
  **(a) (6 pt)** Fill in the environment diagram that results from executing the code below until the entire program is finished, an error occurs, or all frames are filled. *You may not need to use all of the spaces or frames.*
  <hr class="s1" />
  A complete answer will:
  <hr class="s1" />
  - Add all missing names and parent annotations to all local frames.
  - Add all missing values created or referenced during execution.
  - Show the return value for each local frame.

  <hr class="s2" />
  **You are not required to write index numbers in list boxes.**
  <hr class="s2" />
  ![environment diagram](/img/cs61a/mt2-fa15-q2-1.png)

q2_1_s: |
  ![environment diagram](/img/cs61a/mt2-fa15-q2-2.png)

q2_2: |
  **(b) (8 pt)** In each box next to a line of code below, write the **number** of the environment diagram that would result **after** executing that line **and** complete the diagram by adding all missing values (boxes and arrows).
  <hr class="s1" />
  *Suggestion:* You may want to write out the whole diagram elsewhere (scratch paper or the bottom left of this page) before filling in the answer area.
  <hr class="s2" />
  ![environment diagram](/img/cs61a/mt2-fa15-q2-3.png)

q2_2_s: |
  ![environment diagram](/img/cs61a/mt2-fa15-q2-4.png)

q3_1: |
  ## 3. (24 points) Return of the Digits
  **(a) (4 pt)** Implement `complete`, which takes a `Tree` instance `t` and two positive integers `d` and `k`. It returns whether t is `d-k-complete`. A tree is `d-k-complete` if every node at a depth less than `d` has exactly `k` branches and every node at depth `d` is a leaf. *
  <hr class="s1" />
  Notes*: The depth of a node is the number of steps from the root; the root node has depth 0. The built-in `all` function takes a sequence and returns whether all elements are true values: `all([1, 2])` is `True` but `all([0, 1])` is `False`. `Tree` appears on the Midterm 2 Study Guide.

  ```
  def complete(t, d, k):
      """Return whether t is d-k-complete.
      >>> complete(Tree(1), 0, 5)
      True
      >>> u = Tree(1, [Tree(1), Tree(1), Tree(1)])
      >>> [ complete(u, 1, 3) , complete(u, 1, 2) , complete(u, 2, 3) ]
      [True, False, False]
      >>> complete(Tree(1, [u, u, u]), 2, 3)
      True
      """
      if not t.branches:

          return _______________________________________________________________

      bs = [____________________________________________________________________]

      return _______________________________________________________ and all(bs)
  ```

q3_1_s: |
  ```
  def complete(t, d, k):
      """Return whether t is d-k-complete.
      >>> complete(Tree(1), 0, 5)
      True
      >>> u = Tree(1, [Tree(1), Tree(1), Tree(1)])
      >>> [ complete(u, 1, 3) , complete(u, 1, 2) , complete(u, 2, 3) ]
      [True, False, False]
      >>> complete(Tree(1, [u, u, u]), 2, 3)
      True
      """
      if not t.branches:

          return <b>d == 0</b>

      bs = [<b>complete(b, d-1, k) for b in t.branches</b>]

      return <b>len(t.branches) == k</b> and all(bs)
  ```

q3_2: |
  **(b) (4 pt)** Implement `adder`, which takes two lists `x` and `y` of digits representing positive numbers. It mutates `x` to represent the result of adding `x` and `y`. *Notes*: The built-in `reversed` function takes a sequence and returns its elements in reverse order. Assume that `x[0]` and `y[0]` are both positive.

  ```
  def adder(x, y):
      """Adds y into x for lists of digits x and y representing positive numbers.
      >>> a = [3, 4, 5]
      >>> adder(a, [5, 5])           #  345 +    55 =   400
      [4, 0, 0]
      >>> adder(a, [8, 3, 4])        #  400 +   834 =  1234
      [1, 2, 3, 4]
      >>> adder(a, [3, 3, 3, 3, 3])  # 1234 + 33333 = 34567
      [3, 4, 5, 6, 7]
      """
      carry , i = 0, len(x)-1
      for d in reversed([0] + y):

          if ___________________________________________________________________:
              x.insert(0, 0)
              i=0

          d = carry + x[i] + d

          ______________________________________________________________________

      if x[0] == 0:
          x.remove(0)
      return x
  ```

q3_2_s: |
  ```
  def adder(x, y):
      """Adds y into x for lists of digits x and y representing positive numbers.
      >>> a = [3, 4, 5]
      >>> adder(a, [5, 5])           #  345 +    55 =   400
      [4, 0, 0]
      >>> adder(a, [8, 3, 4])        #  400 +   834 =  1234
      [1, 2, 3, 4]
      >>> adder(a, [3, 3, 3, 3, 3])  # 1234 + 33333 = 34567
      [3, 4, 5, 6, 7]
      """
      carry , i = 0, len(x)-1
      for d in reversed([0] + y):

          if <b>i == -1</b>:
              x.insert(0, 0)
              i=0

          d = carry + x[i] + d

          <b>carry, x[i], i = d // 10, d % 10, i-1</b>

      if x[0] == 0:
          x.remove(0)
      return x
  ```

q3_3: |
  **(c) (6 pt)** Implement `multiples`, which takes a positive integer `k` and a linked list `s` of digits **greater than 0 and less than 10**. It returns a linked list of all positive `n` that are multiples of `k` greater than `k` *and* made up of digits only from `s`. The digits in each `n` must appear in the same order as they do in `s`, and each digit from `s` can appear only once in each `n`. The `Link` class appears on the Midterm 2 Study Guide.

  ```
  def multiples(k, s):
      """Return a linked list of all multiples of k selected from digits in s.
      >>> odds = Link(1, Link(3, Link(5, Link(7, Link(9)))))
      >>> multiples(5, odds)
      Link(135, Link(15, Link(35)))
      >>> multiples(7, odds)
      Link (1379 , Link (357 , Link (35)))
      >>> multiples(9, odds)
      Link (1359 , Link (135))
      >>> multiples(2, odds)
      ()
      """

      t = Link.empty

      def f(n, s):

          ______________________________________________________________________

          if s is Link.empty:

              if _______________________________________________________________:

                  t = __________________________________________________________

          else:

              __________________________________________________________________

              __________________________________________________________________

      f(0, s)

      return t
  ```

q3_3_s: |
  ```
  def multiples(k, s):
      """Return a linked list of all multiples of k selected from digits in s.
      >>> odds = Link(1, Link(3, Link(5, Link(7, Link(9)))))
      >>> multiples(5, odds)
      Link(135, Link(15, Link(35)))
      >>> multiples(7, odds)
      Link (1379 , Link (357 , Link (35)))
      >>> multiples(9, odds)
      Link (1359 , Link (135))
      >>> multiples(2, odds)
      ()
      """
      t = Link.empty

      def f(n, s):

          <b>nonlocal t</b>

          if s is Link.empty:

              if <b>s is Link.empty</b>:

                  t = <b>Link(n, t)</b>

          else:

              <b>f(n, s.rest)</b>

              <b>f(n*10+s.first , s.rest)</b>

          f(0, s)

          return t
  ```

q3_4: |
  **(d) (2 pt)** Circle the `Θ` expression that describes the length of the linked list returned by `multiples(1, s)` for an input list of length `n`. Assume `multiples` is implemented correctly.

  ```
  Θ(1)        Θ(log n)        Θ(n)        Θ(n^2)        Θ(2^n)
  ```

q3_4_s: |
  `Θ(2^n)`
  <hr class="s1" />
  **Note:** Θ(1) was also accepted if accompanied by the justification that s would not contain repeated digits.

q3_5: |
  **(e) (8 pt)** Implement `int_set`, which is a higher-order function that takes a list of non-negative integers called `contents`. It returns a function that takes a non-negative integer `n` and returns whether n appears in contents. Your partner left you this clue: Every integer can be expressed uniquely as a sum of powers of 2.
  <hr class="s1" />
  E.g., 5 equals 1 + 4 equals `pow(2, 0) + pow(2, 2)`. The `bits` helper function encodes a list of `nums` using sequences of 0’s and 1’s that tell you whether each power of 2 is used, starting with `pow(2, 0)`.
  <hr class="s1" />
  **Note:** You may *not* use built-in tests of list membership, such as an `in` expression or a list’s `index` method.

  ```
  def bits(nums):
      """A set of nums represented as a function that takes ’entry’, 0, or 1.

      >>> t = bits([4, 5])        # Contains 4 and 5, but not 2
      >>> t(0)(0)(1)(’entry’)     # 4 = 0 * pow(2, 0) + 0 * pow(2, 1) + 1 * pow(2, 2)
      True
      >>> t(0)(1)(’entry’)        # 2 = 0 * pow(2, 0) + 1 * pow(2, 1)
      False
      >>> t(1)(0)(1)(’entry’)     # 5 = 1 * pow(2, 0) + 0 * pow(2, 1) + 1 * pow(2, 2)
      True
      """
      def branch(last):

          if last == ’entry’:

              return 0 in nums

          return ________([_________ for k in nums if _________________________])

      return branch

  def int_set(contents):
      """Return a function that represents a set of non-negative integers.
      >>> int_set([1, 2])(1) , int_set([1, 2])(3) # 1 in [1, 2] but 3 is not
      (True, False)
      >>> s = int_set([1, 3, 4, 7, 9])
      >>> [s(k) for k in range (10)]
      [False , True , False , True , True , False , False , True , False , True]
      """

      index = __________________________________________________________________

      def contains(n):

          t = index

          while n:

              last , _____________ = _____________________ , _____________________

              t = _______________(______________________________________________)

          return t(’entry’)

      return contains
  ```

q3_5_s: |
  ```
  def bits(nums):
      """A set of nums represented as a function that takes ’entry’, 0, or 1.

      >>> t = bits([4, 5]) # Contains 4 and 5, but not 2
      >>> t(0)(0)(1)(’entry’) # 4 = 0 * pow(2, 0) + 0 * pow(2, 1) + 1 * pow(2, 2)
      True
      >>> t(0)(1)(’entry’) # 2 = 0 * pow(2, 0) + 1 * pow(2, 1)
      False
      >>> t(1)(0)(1)(’entry’) # 5 = 1 * pow(2, 0) + 0 * pow(2, 1) + 1 * pow(2, 2)
      True
      """
      def branch(last):

          if last == ’entry’:

              return 0 in nums

          return <b>bits</b>([<b>k // 2</b> for k in nums if <b>k % 2 == last</b>])

      return branch

  def int_set(contents):
      """Return a function that represents a set of non-negative integers.
      >>> int_set([1, 2])(1) , int_set([1, 2])(3) # 1 in [1, 2] but 3 is not
      (True, False)
      >>> s = int_set([1, 3, 4, 7, 9])
      >>> [s(k) for k in range (10)]
      [False , True , False , True , True , False , False , True , False , True]
      """

      index = <b>bits(contents)</b>

      def contains(n):

          t = index

          while n:

              last , <b>n</b> = <b>n % 2</b> , <b>n // 2</b>

              t = <b>t</b>(<b>last</b>)

          return t(’entry’)

      return contains
  ```
